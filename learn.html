<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learn DSA - Code Arena</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: linear-gradient(135deg, #0a0a12 0%, #12121c 100%);
            color: #e8e8f0;
            min-height: 100vh;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 30px;
            background: linear-gradient(90deg, rgba(18, 18, 28, 0.95), rgba(26, 26, 40, 0.95));
            border-bottom: 1px solid rgba(0, 255, 136, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
            font-size: 1.3rem;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #00ff88, #00aa66);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .back-btn {
            padding: 10px 20px;
            background: linear-gradient(145deg, #2a2a3a, #1a1a28);
            border: 1px solid #3a3a4a;
            border-radius: 8px;
            color: #e8e8f0;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
        }

        /* Main Layout */
        .learn-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            height: calc(100vh - 73px);
        }

        /* Sidebar */
        .sidebar {
            background: linear-gradient(180deg, #0f0f18, #0a0a12);
            border-right: 1px solid rgba(42, 42, 58, 0.5);
            overflow-y: auto;
            padding: 20px 0;
        }

        .sidebar-title {
            padding: 0 20px 15px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #6a6a8a;
        }

        .topic-category {
            margin-bottom: 8px;
        }

        .category-header {
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .category-header:hover {
            background: rgba(68, 136, 255, 0.1);
        }

        .category-header.active {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
        }

        .category-icon {
            font-size: 1.1rem;
        }

        .topic-list {
            display: none;
            padding: 5px 0;
        }

        .topic-category.expanded .topic-list {
            display: block;
        }

        .topic-item {
            padding: 10px 20px 10px 50px;
            cursor: pointer;
            font-size: 0.9rem;
            color: #8a8aa0;
            transition: all 0.2s ease;
        }

        .topic-item:hover {
            color: #e8e8f0;
            background: rgba(68, 136, 255, 0.05);
        }

        .topic-item.active {
            color: #00ff88;
            background: rgba(0, 255, 136, 0.08);
        }

        /* Content Area */
        .content {
            overflow-y: auto;
            padding: 30px 40px;
        }

        .topic-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .topic-header h1 {
            font-size: 2rem;
            background: linear-gradient(135deg, #00ff88, #4488ff);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .complexity-badges {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        .badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .badge-time {
            background: rgba(68, 136, 255, 0.2);
            color: #4488ff;
            border: 1px solid rgba(68, 136, 255, 0.3);
        }

        .badge-space {
            background: rgba(170, 102, 255, 0.2);
            color: #aa66ff;
            border: 1px solid rgba(170, 102, 255, 0.3);
        }

        /* Visualization Box */
        .viz-container {
            background: linear-gradient(145deg, #12121c, #0a0a12);
            border: 1px solid rgba(42, 42, 58, 0.5);
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .viz-header {
            padding: 15px 20px;
            background: rgba(26, 26, 40, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(42, 42, 58, 0.5);
        }

        .viz-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .viz-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .viz-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .viz-btn-primary {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #0a0a12;
        }

        .viz-btn-primary:hover {
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
        }

        .viz-btn-secondary {
            background: #2a2a3a;
            color: #e8e8f0;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #8a8aa0;
        }

        .speed-control input {
            width: 80px;
            accent-color: #00ff88;
        }

        .viz-canvas {
            display: flex;
            justify-content: center;
            padding: 20px;
            min-height: 300px;
        }

        /* Theory Section */
        .theory-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .theory-content {
            line-height: 1.8;
            color: #c0c0d0;
        }

        .theory-content p {
            margin-bottom: 15px;
        }

        .theory-content ul,
        .theory-content ol {
            margin: 15px 0 15px 25px;
        }

        .theory-content li {
            margin-bottom: 8px;
        }

        .highlight {
            color: #00ff88;
            font-weight: 600;
        }

        /* Steps Box */
        .steps-box {
            background: linear-gradient(145deg, rgba(26, 42, 26, 0.5), rgba(20, 35, 20, 0.5));
            border: 1px solid rgba(0, 255, 136, 0.15);
            border-radius: 12px;
            padding: 20px 25px;
            margin: 20px 0;
        }

        .steps-box h4 {
            color: #00ff88;
            margin-bottom: 12px;
        }

        .steps-box ol {
            margin-left: 20px;
        }

        /* Code Block */
        .code-section {
            margin-bottom: 30px;
        }

        .code-block {
            background: #0a0a12;
            border: 1px solid rgba(42, 42, 58, 0.5);
            border-radius: 12px;
            overflow: hidden;
        }

        .code-header {
            padding: 12px 18px;
            background: #12121c;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(42, 42, 58, 0.5);
        }

        .code-lang {
            font-size: 0.8rem;
            color: #6a6a8a;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .code-lang::before {
            content: '‚óè';
            color: #00ff88;
            font-size: 0.6rem;
        }

        .code-content {
            padding: 18px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.7;
            overflow-x: auto;
        }

        .code-content .keyword {
            color: #ff79c6;
        }

        .code-content .function {
            color: #50fa7b;
        }

        .code-content .string {
            color: #f1fa8c;
        }

        .code-content .number {
            color: #bd93f9;
        }

        .code-content .comment {
            color: #6272a4;
        }

        /* Info Cards */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .info-card {
            background: linear-gradient(145deg, #1a1a28, #12121c);
            border: 1px solid rgba(42, 42, 58, 0.5);
            border-radius: 12px;
            padding: 18px;
        }

        .info-card h5 {
            color: #4488ff;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .info-card p {
            font-size: 0.85rem;
            color: #a0a0b0;
            line-height: 1.5;
        }
    </style>
</head>

<body>
    <header>
        <div class="logo">
            <div class="logo-icon">üìö</div>
            <span>Learn DSA</span>
        </div>
        <a href="index.html" class="back-btn">‚Üê Back to Arena</a>
    </header>

    <div class="learn-container">
        <nav class="sidebar">
            <div class="sidebar-title">üìñ Topics</div>

            <div class="topic-category expanded" data-category="sorting">
                <div class="category-header active">
                    <span class="category-icon">üìä</span>
                    <span>Sorting Algorithms</span>
                </div>
                <div class="topic-list">
                    <div class="topic-item" data-topic="bubble-sort">Bubble Sort</div>
                    <div class="topic-item" data-topic="selection-sort">Selection Sort</div>
                    <div class="topic-item" data-topic="insertion-sort">Insertion Sort</div>
                    <div class="topic-item" data-topic="merge-sort">Merge Sort</div>
                    <div class="topic-item" data-topic="quick-sort">Quick Sort</div>
                    <div class="topic-item" data-topic="heap-sort">Heap Sort</div>
                </div>
            </div>

            <div class="topic-category" data-category="searching">
                <div class="category-header">
                    <span class="category-icon">üîç</span>
                    <span>Searching</span>
                </div>
                <div class="topic-list">
                    <div class="topic-item" data-topic="linear-search">Linear Search</div>
                    <div class="topic-item" data-topic="binary-search">Binary Search</div>
                </div>
            </div>

            <div class="topic-category" data-category="data-structures">
                <div class="category-header">
                    <span class="category-icon">üóÉÔ∏è</span>
                    <span>Data Structures</span>
                </div>
                <div class="topic-list">
                    <div class="topic-item" data-topic="arrays">Arrays</div>
                    <div class="topic-item" data-topic="linked-list">Linked Lists</div>
                    <div class="topic-item" data-topic="stack">Stacks</div>
                    <div class="topic-item" data-topic="queue">Queues</div>
                    <div class="topic-item" data-topic="hash-table">Hash Tables</div>
                    <div class="topic-item" data-topic="heap">Heaps</div>
                </div>
            </div>

            <div class="topic-category" data-category="trees">
                <div class="category-header">
                    <span class="category-icon">üå≥</span>
                    <span>Trees</span>
                </div>
                <div class="topic-list">
                    <div class="topic-item" data-topic="binary-tree">Binary Trees</div>
                    <div class="topic-item" data-topic="bst">Binary Search Trees</div>
                    <div class="topic-item" data-topic="preorder">Pre-order Traversal</div>
                    <div class="topic-item" data-topic="inorder">In-order Traversal</div>
                    <div class="topic-item" data-topic="postorder">Post-order Traversal</div>
                </div>
            </div>

            <div class="topic-category" data-category="graphs">
                <div class="category-header">
                    <span class="category-icon">üåê</span>
                    <span>Graphs</span>
                </div>
                <div class="topic-list">
                    <div class="topic-item" data-topic="graph-basics">Graph Basics</div>
                    <div class="topic-item" data-topic="bfs">BFS Traversal</div>
                    <div class="topic-item" data-topic="dfs">DFS Traversal</div>
                    <div class="topic-item" data-topic="dijkstra">Dijkstra's Algorithm</div>
                    <div class="topic-item" data-topic="grid-pathfinding">Grid Pathfinding Visualizer</div>
                </div>
            </div>

            <div class="topic-category" data-category="dp">
                <div class="category-header">
                    <span class="category-icon">üî¢</span>
                    <span>Dynamic Programming</span>
                </div>
                <div class="topic-list">
                    <div class="topic-item" data-topic="dp-fib">DP (Fibonacci)</div>
                    <div class="topic-item" data-topic="dp-knapsack">0/1 Knapsack</div>
                    <div class="topic-item" data-topic="dp-lcs">Longest Common Subsequence</div>
                    <div class="topic-item" data-topic="dp-coin">Coin Change</div>
                </div>
            </div>

            <div class="topic-category" data-category="backtracking">
                <div class="category-header">
                    <span class="category-icon">üîô</span>
                    <span>Backtracking</span>
                </div>
                <div class="topic-list">
                    <div class="topic-item" data-topic="n-queens">N-Queens Problem</div>
                    <div class="topic-item" data-topic="sudoku-solver">Sudoku Solver</div>
                    <div class="topic-item" data-topic="maze-solver">Maze Solver</div>
                </div>
            </div>
        </nav>

        <main class="content" id="content">
            <!-- Content will be loaded dynamically -->
        </main>
    </div>

    <script>
        // Topic content data
        const TOPICS = {
            'bubble-sort': {
                title: 'Bubble Sort',
                icon: 'ü´ß',
                timeComplexity: 'O(n¬≤)',
                spaceComplexity: 'O(1)',
                description: `
                    <p><span class="highlight">Bubble Sort</span> is the simplest sorting algorithm. 
                    It works by repeatedly stepping through the list, comparing adjacent elements, 
                    and swapping them if they are in the wrong order.</p>
                    
                    <p>The algorithm gets its name because smaller elements "bubble" to the top 
                    of the list with each pass, like bubbles rising in water.</p>
                `,
                steps: [
                    'Start from the first element',
                    'Compare it with the next element',
                    'If the first is greater, swap them',
                    'Move to the next pair and repeat',
                    'After one pass, the largest element is at the end',
                    'Repeat for remaining elements'
                ],
                code: `function bubbleSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        // Flag to optimize if no swaps occur
        let swapped = false;
        
        for (let j = 0; j < n - i - 1; j++) {
            // Compare adjacent elements
            if (arr[j] > arr[j + 1]) {
                // Swap them
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                swapped = true;
            }
        }
        
        // If no swaps, array is sorted
        if (!swapped) break;
    }
    
    return arr;
}`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'Simple to understand and implement. Works well for small datasets. Stable sort (maintains relative order).' },
                    { title: '‚ùå Cons', text: 'Very slow for large datasets. O(n¬≤) makes it impractical for production use.' },
                    { title: 'üéØ Best Use Cases', text: 'Educational purposes. Nearly sorted arrays. Small datasets (< 50 elements).' }
                ]
            },
            'selection-sort': {
                title: 'Selection Sort',
                icon: 'üëÜ',
                timeComplexity: 'O(n¬≤)',
                spaceComplexity: 'O(1)',
                description: `
                    <p><span class="highlight">Selection Sort</span> works by repeatedly finding the minimum element 
                    from the unsorted portion and placing it at the beginning.</p>
                    
                    <p>The algorithm divides the array into two parts: a sorted portion (left) and an unsorted 
                    portion (right). In each iteration, it selects the smallest element from the unsorted part 
                    and swaps it with the first unsorted element.</p>
                    
                    <p>Unlike Bubble Sort which swaps adjacent elements, Selection Sort minimizes the number 
                    of swaps to exactly <span class="highlight">n-1 swaps</span> in the worst case.</p>
                `,
                steps: [
                    'Start with the first position as sorted boundary',
                    'Find the minimum element in the unsorted portion',
                    'Swap it with the first unsorted element',
                    'Move the sorted boundary one position right',
                    'Repeat until the entire array is sorted'
                ],
                code: `function selectionSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        // Find minimum element in unsorted portion
        let minIndex = i;
        
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Swap minimum with first unsorted element
        if (minIndex !== i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
        }
    }
    
    return arr;
}`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'Simple implementation. Minimal swaps (O(n)). Works well when memory writes are expensive.' },
                    { title: '‚ùå Cons', text: 'O(n¬≤) comparisons regardless of input. Not stable. No benefit from partially sorted data.' },
                    { title: 'üéØ Best Use Cases', text: 'When swap operations are costly. Small datasets. When simplicity is preferred over efficiency.' }
                ]
            },
            'insertion-sort': {
                title: 'Insertion Sort',
                icon: 'üì•',
                timeComplexity: 'O(n¬≤)',
                spaceComplexity: 'O(1)',
                description: `
                    <p><span class="highlight">Insertion Sort</span> builds the final sorted array one element at a time. 
                    It works similarly to how you might sort playing cards in your hand.</p>
                    
                    <p>The algorithm picks one element at a time and inserts it into its correct position 
                    among the previously sorted elements. Elements are shifted right to make room for the 
                    inserted element.</p>
                    
                    <p>This algorithm is <span class="highlight">adaptive</span> - it performs well on 
                    nearly sorted data, achieving O(n) time complexity in the best case.</p>
                `,
                steps: [
                    'Start from the second element (first is considered sorted)',
                    'Pick the current element as the "key"',
                    'Compare the key with sorted elements (left side)',
                    'Shift larger elements one position right',
                    'Insert the key in its correct position',
                    'Move to the next unsorted element and repeat'
                ],
                code: `function insertionSort(arr) {
    const n = arr.length;
    
    for (let i = 1; i < n; i++) {
        // Element to be inserted
        let key = arr[i];
        let j = i - 1;
        
        // Shift elements greater than key to the right
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // Insert key at correct position
        arr[j + 1] = key;
    }
    
    return arr;
}`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'Efficient for small datasets. Adaptive (fast on nearly sorted data). Stable sort. Online (can sort as data arrives).' },
                    { title: '‚ùå Cons', text: 'O(n¬≤) worst case. Many shifts required for reverse-sorted data.' },
                    { title: 'üéØ Best Use Cases', text: 'Nearly sorted arrays. Small datasets. Online sorting. When stability matters.' }
                ]
            },
            'merge-sort': {
                title: 'Merge Sort',
                icon: 'üîÄ',
                timeComplexity: 'O(n log n)',
                spaceComplexity: 'O(n)',
                description: `
                    <p><span class="highlight">Merge Sort</span> is a divide-and-conquer algorithm that divides 
                    the array into halves, recursively sorts them, and then merges the sorted halves.</p>
                    
                    <p>It's one of the most efficient sorting algorithms with a guaranteed 
                    <span class="highlight">O(n log n)</span> time complexity in all cases - best, average, and worst.</p>
                    
                    <p>The key insight is that merging two sorted arrays is O(n), and we only need log(n) 
                    levels of division, giving us O(n log n) total.</p>
                `,
                steps: [
                    'Divide the array into two halves',
                    'Recursively sort the left half',
                    'Recursively sort the right half',
                    'Merge the two sorted halves',
                    'Compare elements from both halves and place smaller one first',
                    'Continue until all elements are merged'
                ],
                code: `function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    // Divide
    const mid = Math.floor(arr.length / 2);
    const left = arr.slice(0, mid);
    const right = arr.slice(mid);
    
    // Conquer (recursive sort)
    const sortedLeft = mergeSort(left);
    const sortedRight = mergeSort(right);
    
    // Merge
    return merge(sortedLeft, sortedRight);
}

function merge(left, right) {
    let result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }
    
    // Add remaining elements
    return result.concat(left.slice(i)).concat(right.slice(j));
}`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'Guaranteed O(n log n). Stable sort. Predictable performance. Great for linked lists.' },
                    { title: '‚ùå Cons', text: 'O(n) extra space required. Not in-place. Slower for small arrays due to recursion overhead.' },
                    { title: 'üéØ Best Use Cases', text: 'Large datasets. External sorting. When stability is required. Linked list sorting.' }
                ]
            },
            'quick-sort': {
                title: 'Quick Sort',
                icon: '‚ö°',
                timeComplexity: 'O(n log n) avg',
                spaceComplexity: 'O(log n)',
                description: `
                    <p><span class="highlight">Quick Sort</span> is a highly efficient divide-and-conquer algorithm. 
                    It picks a "pivot" element and partitions the array around it.</p>
                    
                    <p>Elements smaller than the pivot go to the left, larger ones go to the right. 
                    This process is repeated recursively on the sub-arrays.</p>
                    
                    <p>Despite O(n¬≤) worst case, Quick Sort is often <span class="highlight">faster in practice</span> 
                    than Merge Sort due to better cache performance and smaller constant factors.</p>
                `,
                steps: [
                    'Choose a pivot element (often the last element)',
                    'Partition: move smaller elements left, larger right',
                    'Place pivot in its correct sorted position',
                    'Recursively apply to left sub-array',
                    'Recursively apply to right sub-array',
                    'Base case: arrays of size 0 or 1 are already sorted'
                ],
                code: `function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        // Partition and get pivot index
        const pivotIdx = partition(arr, low, high);
        
        // Recursively sort sub-arrays
        quickSort(arr, low, pivotIdx - 1);
        quickSort(arr, pivotIdx + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    // Place pivot in correct position
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'Fast in practice. In-place (O(log n) stack space). Cache efficient. Good for arrays.' },
                    { title: '‚ùå Cons', text: 'O(n¬≤) worst case (sorted input). Not stable. Recursion overhead.' },
                    { title: 'üéØ Best Use Cases', text: 'General purpose sorting. When average case matters more. Arrays (not linked lists).' }
                ]
            },
            'heap-sort': {
                title: 'Heap Sort',
                icon: 'üèîÔ∏è',
                timeComplexity: 'O(n log n)',
                spaceComplexity: 'O(1)',
                description: `
                    <p><span class="highlight">Heap Sort</span> uses a <span class="highlight">Binary Heap</span> data structure 
                    to sort elements. It treats the array as a complete binary tree.</p>
                    
                    <p>Phase 1: Build a Max Heap (largest element at root).<br>
                    Phase 2: Swap root with last element, reduce heap size, and "heapify" down.</p>
                    
                    <p>Guarantees <span class="highlight">O(n log n)</span> time complexity like Merge Sort, but sorts 
                    <span class="highlight">in-place</span> like Quick Sort!</p>
                `,
                steps: [
                    'Build Max Heap from unordered array',
                    'Swap root (max value) with last element',
                    'Reduce heap size by 1',
                    'Heapify the new root to restore max heap property',
                    'Repeat until heap size is 1',
                    'Result: Array is sorted in ascending order'
                ],
                code: `function heapSort(arr) {
    const n = arr.length;

    // Build max heap
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Extract elements from heap one by one
    for (let i = n - 1; i > 0; i--) {
        // Move current root to end
        [arr[0], arr[i]] = [arr[i], arr[0]];

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
    return arr;
}

function heapify(arr, n, i) {
    let largest = i;
    const left = 2 * i + 1;
    const right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, n, largest);
    }
}`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'O(n log n) worst case. In-place (O(1) extra space). No recursion stack overhead.' },
                    { title: '‚ùå Cons', text: 'Unstable. Slower typical performace than Quick Sort due to poor locality of reference.' },
                    { title: 'üéØ Best Use Cases', text: 'Embedded systems (low memory). Real-time systems (guaranteed time limits).' }
                ]
            },
            'linear-search': {
                title: 'Linear Search',
                icon: 'üëÅÔ∏è',
                timeComplexity: 'O(n)',
                spaceComplexity: 'O(1)',
                description: `
                    <p><span class="highlight">Linear Search</span> is the simplest searching algorithm. 
                    It sequentially checks each element until a match is found or the entire list has been searched.</p>
                    
                    <p>It works on both <span class="highlight">sorted and unsorted</span> arrays, making it 
                    versatile but not optimal for large datasets.</p>
                    
                    <p>While simple, it's often the only option when data is unsorted or when dealing with 
                    linked lists where random access isn't available.</p>
                `,
                steps: [
                    'Start from the first element',
                    'Compare current element with target',
                    'If match found, return the index',
                    'If not, move to the next element',
                    'Repeat until element found or end reached',
                    'Return -1 if element not found'
                ],
                code: `function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;  // Element found at index i
        }
    }
    return -1;  // Element not found
}

// Example usage:
const numbers = [4, 2, 7, 1, 9, 3];
const result = linearSearch(numbers, 7);
// result = 2 (index of 7)`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'Simple implementation. Works on unsorted data. No preprocessing needed. O(1) space.' },
                    { title: '‚ùå Cons', text: 'O(n) time - slow for large datasets. Checks every element in worst case.' },
                    { title: 'üéØ Best Use Cases', text: 'Small datasets. Unsorted arrays. Linked lists. When data changes frequently.' }
                ]
            },
            'binary-search': {
                title: 'Binary Search',
                icon: 'üéØ',
                timeComplexity: 'O(log n)',
                spaceComplexity: 'O(1)',
                description: `
                    <p><span class="highlight">Binary Search</span> is a highly efficient algorithm that works 
                    on <span class="highlight">sorted arrays</span> by repeatedly dividing the search interval in half.</p>
                    
                    <p>It compares the target with the middle element. If they're equal, we're done. 
                    If target is smaller, search the left half. If larger, search the right half.</p>
                    
                    <p>With each comparison, we eliminate half the remaining elements, giving us 
                    <span class="highlight">O(log n)</span> time complexity - exponentially faster than linear search!</p>
                `,
                steps: [
                    'Find the middle element of the array',
                    'If middle equals target, return its index',
                    'If target is smaller, search left half',
                    'If target is larger, search right half',
                    'Repeat until found or range is empty',
                    'Return -1 if not found'
                ],
                code: `function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;  // Found!
        } else if (arr[mid] < target) {
            left = mid + 1;  // Search right half
        } else {
            right = mid - 1;  // Search left half
        }
    }
    
    return -1;  // Not found
}

// Example: searching in sorted array
const sorted = [1, 3, 5, 7, 9, 11, 13];
binarySearch(sorted, 7);  // returns 3`,
                infoCards: [
                    { title: '‚úÖ Pros', text: 'O(log n) time - very fast! Efficient for large sorted datasets.' },
                    { title: '‚ùå Cons', text: 'Requires sorted array. Random access needed (arrays only).' },
                    { title: 'üéØ Best Use Cases', text: 'Large sorted arrays. Dictionaries. Database indexing. Finding boundaries.' }
                ]
            },
            'arrays': {
                title: 'Arrays',
                icon: 'üì¶',
                timeComplexity: 'O(1) access',
                spaceComplexity: 'O(n)',
                description: `
                    <p><span class="highlight">Arrays</span> are the most fundamental data structure. They store 
                    elements in contiguous memory locations, allowing direct access via index.</p>
                    
                    <p>Key property: <span class="highlight">Random Access in O(1)</span> - you can access any 
                    element instantly using its index, like arr[5].</p>
                    
                    <p>Trade-off: Insertion and deletion are O(n) because elements need to be shifted.</p>
                `,
                steps: [
                    'Elements stored in contiguous memory',
                    'Access any element by index in O(1)',
                    'Insertion at end: O(1) amortized',
                    'Insertion at beginning/middle: O(n)',
                    'Deletion requires shifting elements',
                    'Fixed size (static) or dynamic (resizable)'
                ],
                code: `// Array Operations in JavaScript

// Create array
const arr = [10, 20, 30, 40, 50];

// Access - O(1)
arr[2];  // 30

// Update - O(1)
arr[2] = 35;

// Push (end) - O(1) amortized
arr.push(60);

// Pop (end) - O(1)
arr.pop();

// Insert at index - O(n)
arr.splice(2, 0, 25);  // Insert 25 at index 2

// Delete at index - O(n)
arr.splice(2, 1);  // Remove element at index 2

// Search - O(n)
arr.indexOf(30);  // Returns index or -1`,
                infoCards: [
                    { title: '‚è±Ô∏è Time Complexity', text: 'Access: O(1) | Search: O(n) | Insert/Delete: O(n) | Push/Pop: O(1)' },
                    { title: '‚úÖ Pros', text: 'Fast random access. Cache friendly. Simple to use.' },
                    { title: 'üéØ Best Use Cases', text: 'When you need fast access by index. Fixed-size collections. Implementing other data structures.' }
                ]
            },
            'stack': {
                title: 'Stacks',
                icon: 'üìö',
                timeComplexity: 'O(1) push/pop',
                spaceComplexity: 'O(n)',
                description: `
                    <p><span class="highlight">Stack</span> is a LIFO (Last In, First Out) data structure. 
                    Think of a stack of plates - you can only add or remove from the top.</p>
                    
                    <p>Two main operations: <span class="highlight">push</span> (add to top) and 
                    <span class="highlight">pop</span> (remove from top), both in O(1) time.</p>
                    
                    <p>Stacks are used everywhere: function call stack, undo operations, expression parsing, etc.</p>
                `,
                steps: [
                    'Push: Add element to the top',
                    'Pop: Remove element from the top',
                    'Peek: View top element without removing',
                    'isEmpty: Check if stack is empty',
                    'All operations are O(1)',
                    'LIFO principle: Last In, First Out'
                ],
                code: `class Stack {
    constructor() {
        this.items = [];
    }
    
    // Add to top - O(1)
    push(element) {
        this.items.push(element);
    }
    
    // Remove from top - O(1)
    pop() {
        if (this.isEmpty()) return null;
        return this.items.pop();
    }
    
    // View top element - O(1)
    peek() {
        return this.items[this.items.length - 1];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}

// Usage
const stack = new Stack();
stack.push(10);
stack.push(20);
stack.pop();   // 20
stack.peek();  // 10`,
                infoCards: [
                    { title: '‚è±Ô∏è Time Complexity', text: 'Push: O(1) | Pop: O(1) | Peek: O(1) | Search: O(n)' },
                    { title: 'üîß Applications', text: 'Function call stack. Undo/Redo. Expression evaluation. Backtracking algorithms.' },
                    { title: 'üéØ Best Use Cases', text: 'When you need LIFO access. Recursion simulation. Parenthesis matching.' }
                ]
            },
            'queue': {
                title: 'Queues',
                icon: 'üö∂‚Äç‚ôÇÔ∏è',
                timeComplexity: 'O(1) enqueue/dequeue',
                spaceComplexity: 'O(n)',
                description: `
                    <p><span class="highlight">Queue</span> is a FIFO (First In, First Out) data structure. 
                    Like a line at a store - first person in line is first to be served.</p>
                    
                    <p>Two main operations: <span class="highlight">enqueue</span> (add to back) and 
                    <span class="highlight">dequeue</span> (remove from front).</p>
                    
                    <p>Queues are essential for BFS, task scheduling, buffering, and message handling.</p>
                `,
                steps: [
                    'Enqueue: Add element to the back',
                    'Dequeue: Remove element from the front',
                    'Front: View first element without removing',
                    'isEmpty: Check if queue is empty',
                    'FIFO principle: First In, First Out',
                    'Variations: Priority Queue, Circular Queue'
                ],
                code: `class Queue {
    constructor() {
        this.items = [];
    }
    
    // Add to back - O(1)
    enqueue(element) {
        this.items.push(element);
    }
    
    // Remove from front - O(n) with array
    // O(1) with linked list implementation
    dequeue() {
        if (this.isEmpty()) return null;
        return this.items.shift();
    }
    
    // View front element - O(1)
    front() {
        return this.items[0];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}

// Usage
const queue = new Queue();
queue.enqueue(10);
queue.enqueue(20);
queue.dequeue();  // 10
queue.front();    // 20`,
                infoCards: [
                    { title: '‚è±Ô∏è Time Complexity', text: 'Enqueue: O(1) | Dequeue: O(1)* | Front: O(1) *with proper implementation' },
                    { title: 'üîß Applications', text: 'BFS traversal. Task scheduling. Print queue. Message brokers.' },
                    { title: 'üéØ Best Use Cases', text: 'When you need FIFO access. Level-order processing. Resource management.' }
                ]
            },
            'linked-list': {
                title: 'Linked Lists',
                icon: 'üîó',
                timeComplexity: 'O(1) insert/delete',
                spaceComplexity: 'O(n)',
                description: `
                    <p><span class="highlight">Linked List</span> is a linear data structure where elements 
                    are stored in nodes, and each node points to the next node.</p>
                    
                    <p>Unlike arrays, linked lists don't require contiguous memory. This enables 
                    <span class="highlight">O(1) insertion and deletion</span> at any position (if you have the reference).</p>
                    
                    <p>Trade-off: No random access - you must traverse from the head to find an element.</p>
                `,
                steps: [
                    'Each node contains data and a pointer to next',
                    'Head points to the first node',
                    'Last node points to null',
                    'Insert at head: O(1)',
                    'Insert at tail: O(n) or O(1) with tail pointer',
                    'Search requires traversal: O(n)'
                ],
                code: `class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
    }
    
    // Insert at head - O(1)
    prepend(data) {
        const newNode = new Node(data);
        newNode.next = this.head;
        this.head = newNode;
    }
    
    // Insert at tail - O(n)
    append(data) {
        const newNode = new Node(data);
        if (!this.head) {
            this.head = newNode;
            return;
        }
        let current = this.head;
        while (current.next) {
            current = current.next;
        }
        current.next = newNode;
    }
    
    // Delete node - O(n) to find
    delete(data) {
        if (!this.head) return;
        if (this.head.data === data) {
            this.head = this.head.next;
            return;
        }
        let current = this.head;
        while (current.next) {
            if (current.next.data === data) {
                current.next = current.next.next;
                return;
            }
            current = current.next;
        }
    }
}`,
                infoCards: [
                    { title: '‚è±Ô∏è Time Complexity', text: 'Insert/Delete at known position: O(1) | Search: O(n) | Access by index: O(n)' },
                    { title: '‚úÖ Pros', text: 'Dynamic size. Efficient insertions/deletions. No wasted memory.' },
                    { title: 'üéØ Best Use Cases', text: 'Frequent insertions/deletions. Implementing stacks/queues. When size is unknown.' }
                ]
            },
            'hash-table': {
                title: 'Hash Tables',
                icon: '#Ô∏è‚É£',
                timeComplexity: 'O(1) average',
                spaceComplexity: 'O(n)',
                description: `
                    <p><span class="highlight">Hash Table</span> (also called Hash Map) stores key-value pairs 
                    and provides near-instant lookup using a hash function.</p>
                    
                    <p>The hash function converts a key into an array index, allowing 
                    <span class="highlight">O(1) average time</span> for insert, delete, and lookup operations.</p>
                    
                    <p>Collisions (when two keys hash to the same index) are handled via chaining (linked lists) 
                    or open addressing (probing).</p>
                `,
                steps: [
                    'Hash function converts key to index',
                    'Store value at computed index',
                    'Handle collisions (chaining or probing)',
                    'Lookup: hash key, check index',
                    'Resize when load factor exceeds threshold',
                    'Average O(1), worst case O(n)'
                ],
                code: `class HashTable {
    constructor(size = 53) {
        this.buckets = new Array(size);
        this.size = size;
    }
    
    // Simple hash function
    hash(key) {
        let total = 0;
        const PRIME = 31;
        for (let i = 0; i < Math.min(key.length, 100); i++) {
            const char = key.charCodeAt(i);
            total = (total * PRIME + char) % this.size;
        }
        return total;
    }
    
    // Set key-value pair - O(1) avg
    set(key, value) {
        const idx = this.hash(key);
        if (!this.buckets[idx]) {
            this.buckets[idx] = [];
        }
        // Update if key exists
        const existing = this.buckets[idx].find(p => p[0] === key);
        if (existing) {
            existing[1] = value;
        } else {
            this.buckets[idx].push([key, value]);
        }
    }
    
    // Get value by key - O(1) avg
    get(key) {
        const idx = this.hash(key);
        const bucket = this.buckets[idx];
        if (bucket) {
            const pair = bucket.find(p => p[0] === key);
            return pair ? pair[1] : undefined;
        }
        return undefined;
    }
}

// Usage
const map = new HashTable();
map.set("name", "Alice");
map.set("age", 25);
map.get("name");  // "Alice"`,
                infoCards: [
                    { title: '‚è±Ô∏è Time Complexity', text: 'Insert/Delete/Lookup: O(1) average, O(n) worst case' },
                    { title: 'üîß Applications', text: 'Dictionaries. Caching. Database indexing. Symbol tables. Counting frequencies.' },
                    { title: 'üéØ Best Use Cases', text: 'Fast lookup by key. Counting occurrences. Implementing sets. Memoization.' }
                ]
            },
            'heap': {
                title: 'Heaps (Priority Queue)',
                icon: 'üèîÔ∏è',
                timeComplexity: 'O(log n)',
                spaceComplexity: 'O(n)',
                description: `
                    <p>A <span class="highlight">Heap</span> is a specialized tree-based data structure that satisfies the heap property.
                    It's commonly implemented as a <span class="highlight">Binary Heap</span> using an array.</p>
                    
                    <p><span class="highlight">Max Heap</span>: Parent ‚â• Children (Root = Max).<br>
                    <span class="highlight">Min Heap</span>: Parent ‚â§ Children (Root = Min).</p>
                    
                    <p>Heaps are efficiently used to implement Priority Queues, where we always want fast access to the 
                    highest (or lowest) priority element.</p>
                `,
                steps: [
                    'Complete Binary Tree: Filled level by level, left to right',
                    'Heap Property: Parent is always greater/smaller than children',
                    'Insert: Add to end, then bubble up',
                    'Extract Max/Min: Remove root, move last element to root, sink down',
                    'Root always contains the max (or min) element',
                    'Efficient O(log n) operations'
                ],
                code: `class MinHeap {
    constructor() {
        this.heap = [];
    }

    // O(log n)
    insert(val) {
        this.heap.push(val);
        this.bubbleUp();
    }

    bubbleUp() {
        let index = this.heap.length - 1;
        while (index > 0) {
            let parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[parentIndex] <= this.heap[index]) break;
            [this.heap[parentIndex], this.heap[index]] = 
                [this.heap[index], this.heap[parentIndex]];
            index = parentIndex;
        }
    }

    // O(log n)
    extractMin() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this.sinkDown();
        }
        return min;
    }

    sinkDown() {
        let idx = 0;
        const length = this.heap.length;
        while (true) {
            let leftIdx = 2 * idx + 1;
            let rightIdx = 2 * idx + 2;
            let swap = null;

            if (leftIdx < length) {
                if (this.heap[leftIdx] < this.heap[idx]) {
                    swap = leftIdx;
                }
            }
            if (rightIdx < length) {
                if ((swap === null && this.heap[rightIdx] < this.heap[idx]) || 
                    (swap !== null && this.heap[rightIdx] < this.heap[leftIdx])) {
                    swap = rightIdx;
                }
            }
            if (swap === null) break;
            [this.heap[idx], this.heap[swap]] = [this.heap[swap], this.heap[idx]];
            idx = swap;
        }
    }
}`,
                infoCards: [
                    { title: '‚è±Ô∏è Time Complexity', text: 'Insert: O(log n). Extract Min/Max: O(log n). Peek: O(1).' },
                    { title: 'üîß Applications', text: 'Priority Queues. Scheduling tasks. Dijkstra\'s Algorithm. Huffman Coding. Median finding.' },
                    { title: 'üéØ Best Use Cases', text: 'When you constantly need the min or max element. Priority-based processing.' }
                ]
            },
            'binary-tree': {
                title: 'Binary Trees',
                icon: 'üå≤',
                timeComplexity: 'O(n) traversal',
                spaceComplexity: 'O(h) recursion',
                description: `
                    <p><span class="highlight">Binary Tree</span> is a hierarchical data structure where each 
                    node has at most two children: left and right.</p>
                    
                    <p>The topmost node is called the <span class="highlight">root</span>. Nodes without 
                    children are called <span class="highlight">leaves</span>.</p>
                    
                    <p>Tree height (h) affects performance: balanced trees have h = log(n), skewed trees have h = n.</p>
                `,
                steps: [
                    'Root is the topmost node',
                    'Each node has at most 2 children',
                    'Left subtree and right subtree',
                    'Leaf nodes have no children',
                    'Height = longest path from root to leaf',
                    'Full, Complete, Perfect variants'
                ],
                code: `class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

// Create a binary tree
const root = new TreeNode(10);
root.left = new TreeNode(5);
root.right = new TreeNode(15);
root.left.left = new TreeNode(3);
root.left.right = new TreeNode(7);

// Tree structure:
//       10
//      /  \\
//     5    15
//    / \\
//   3   7`,
                infoCards: [
                    { title: 'üìê Properties', text: 'Max nodes at level i: 2^i. Max nodes in tree of height h: 2^(h+1) - 1' },
                    { title: 'üîß Applications', text: 'Expression trees. Decision trees. File systems. DOM structure.' },
                    { title: 'üéØ Types', text: 'Full (0 or 2 children). Complete (filled left to right). Perfect (all leaves same level).' }
                ]
            },
            'bst': {
                title: 'Binary Search Trees',
                icon: 'üîç',
                timeComplexity: 'O(log n) avg',
                spaceComplexity: 'O(n)',
                description: `
                    <p><span class="highlight">Binary Search Tree (BST)</span> is a binary tree with an ordering 
                    property: left subtree contains smaller values, right subtree contains larger values.</p>
                    
                    <p>This property enables <span class="highlight">O(log n)</span> average time for 
                    search, insert, and delete operations.</p>
                    
                    <p>Warning: Inserting sorted data creates a skewed tree with O(n) operations. 
                    Use balanced trees (AVL, Red-Black) to prevent this.</p>
                `,
                steps: [
                    'Left child < Parent < Right child',
                    'Search: compare and go left or right',
                    'Insert: find correct position, add node',
                    'Delete: handle 0, 1, or 2 children cases',
                    'In-order traversal gives sorted order',
                    'Balance for optimal performance'
                ],
                code: `class BST {
    constructor() {
        this.root = null;
    }
    
    insert(val) {
        const node = new TreeNode(val);
        if (!this.root) {
            this.root = node;
            return;
        }
        let curr = this.root;
        while (true) {
            if (val < curr.val) {
                if (!curr.left) { curr.left = node; return; }
                curr = curr.left;
            } else {
                if (!curr.right) { curr.right = node; return; }
                curr = curr.right;
            }
        }
    }
    
    search(val) {
        let curr = this.root;
        while (curr) {
            if (val === curr.val) return curr;
            curr = val < curr.val ? curr.left : curr.right;
        }
        return null;
    }
}`,
                infoCards: [
                    { title: '‚è±Ô∏è Time Complexity', text: 'Search/Insert/Delete: O(log n) avg, O(n) worst (unbalanced)' },
                    { title: '‚úÖ Pros', text: 'Ordered data. Efficient search. In-order gives sorted sequence.' },
                    { title: 'üéØ Best Use Cases', text: 'Maintaining sorted data. Range queries. Priority queues.' }
                ]
            },
            'preorder': {
                title: 'Pre-order Traversal',
                icon: '1Ô∏è‚É£',
                timeComplexity: 'O(n)',
                spaceComplexity: 'O(h)',
                description: `
                    <p><span class="highlight">Pre-order Traversal</span> visits nodes in the order: 
                    <span class="highlight">Root ‚Üí Left ‚Üí Right</span>.</p>
                    
                    <p>The root is processed FIRST, before its children. This is useful for 
                    <span class="highlight">copying a tree</span> or creating a prefix expression.</p>
                    
                    <p>Think of it as: "Visit me first, then explore my children."</p>
                `,
                steps: [
                    'Visit the root node first',
                    'Recursively traverse the left subtree',
                    'Recursively traverse the right subtree',
                    'Process: Root ‚Üí Left ‚Üí Right',
                    'Useful for copying/cloning trees',
                    'Creates prefix notation for expressions'
                ],
                code: `function preOrder(node) {
    if (!node) return;
    
    console.log(node.val);  // 1. Process ROOT first
    preOrder(node.left);     // 2. Then LEFT subtree
    preOrder(node.right);    // 3. Then RIGHT subtree
}

// Example tree:
//       10
//      /  \\
//     5    15
//    / \\
//   3   7

// Pre-order output: 10, 5, 3, 7, 15`,
                infoCards: [
                    { title: 'üìã Order', text: 'Root ‚Üí Left ‚Üí Right. The root is always visited FIRST.' },
                    { title: 'üîß Use Cases', text: 'Copy/clone tree. Serialize tree. Create prefix expression.' },
                    { title: 'üí° Remember', text: '"Pre" = Process node BEFORE children (pre-fix).' }
                ]
            },
            'inorder': {
                title: 'In-order Traversal',
                icon: '2Ô∏è‚É£',
                timeComplexity: 'O(n)',
                spaceComplexity: 'O(h)',
                description: `
                    <p><span class="highlight">In-order Traversal</span> visits nodes in the order: 
                    <span class="highlight">Left ‚Üí Root ‚Üí Right</span>.</p>
                    
                    <p>For a Binary Search Tree, this gives nodes in <span class="highlight">sorted ascending order</span>! 
                    This is the most common traversal for BSTs.</p>
                    
                    <p>Think of it as: "Go left first, then visit me, then go right."</p>
                `,
                steps: [
                    'Recursively traverse the left subtree',
                    'Visit the root node',
                    'Recursively traverse the right subtree',
                    'Process: Left ‚Üí Root ‚Üí Right',
                    'BST in-order = sorted sequence!',
                    'Creates infix notation for expressions'
                ],
                code: `function inOrder(node) {
    if (!node) return;
    
    inOrder(node.left);      // 1. First LEFT subtree
    console.log(node.val);   // 2. Then process ROOT
    inOrder(node.right);     // 3. Then RIGHT subtree
}

// Example BST:
//       10
//      /  \\
//     5    15
//    / \\
//   3   7

// In-order output: 3, 5, 7, 10, 15 (SORTED!)`,
                infoCards: [
                    { title: 'üìã Order', text: 'Left ‚Üí Root ‚Üí Right. Root is visited IN the MIDDLE.' },
                    { title: 'üîß Use Cases', text: 'Get sorted data from BST. Validate BST. Expression trees.' },
                    { title: 'üí° Remember', text: '"In" = Process node IN-between children (in-fix).' }
                ]
            },
            'postorder': {
                title: 'Post-order Traversal',
                icon: '3Ô∏è‚É£',
                timeComplexity: 'O(n)',
                spaceComplexity: 'O(h)',
                description: `
                    <p><span class="highlight">Post-order Traversal</span> visits nodes in the order: 
                    <span class="highlight">Left ‚Üí Right ‚Üí Root</span>.</p>
                    
                    <p>The root is processed LAST, after all children. This is useful for 
                    <span class="highlight">deleting a tree</span> (children before parent) or postfix expressions.</p>
                    
                    <p>Think of it as: "Visit all my children first, then visit me."</p>
                `,
                steps: [
                    'Recursively traverse the left subtree',
                    'Recursively traverse the right subtree',
                    'Visit the root node last',
                    'Process: Left ‚Üí Right ‚Üí Root',
                    'Useful for deleting trees safely',
                    'Creates postfix notation (RPN)'
                ],
                code: `function postOrder(node) {
    if (!node) return;
    
    postOrder(node.left);    // 1. First LEFT subtree
    postOrder(node.right);   // 2. Then RIGHT subtree
    console.log(node.val);   // 3. Process ROOT last
}

// Example tree:
//       10
//      /  \\
//     5    15
//    / \\
//   3   7

// Post-order output: 3, 7, 5, 15, 10`,
                infoCards: [
                    { title: 'üìã Order', text: 'Left ‚Üí Right ‚Üí Root. Root is visited LAST.' },
                    { title: 'üîß Use Cases', text: 'Delete tree (children first). Calculate folder sizes. Postfix expressions.' },
                    { title: 'üí° Remember', text: '"Post" = Process node AFTER children (post-fix).' }
                ]
            },
            'bfs': {
                title: 'BFS Traversal',
                icon: 'üåä',
                timeComplexity: 'O(V + E)',
                spaceComplexity: 'O(V)',
                description: `
                    <p><span class="highlight">Breadth-First Search (BFS)</span> explores a graph level by level, 
                    visiting all neighbors before moving to the next depth.</p>
                    
                    <p>Uses a <span class="highlight">queue</span> to track which node to visit next. 
                    Perfect for finding the <span class="highlight">shortest path</span> in unweighted graphs.</p>
                `,
                steps: [
                    'Start from source node, add to queue',
                    'Mark source as visited',
                    'While queue not empty:',
                    '  - Dequeue a node, process it',
                    '  - Enqueue all unvisited neighbors',
                    '  - Mark neighbors as visited'
                ],
                code: `function bfs(graph, start) {
    const visited = new Set();
    const queue = [start];
    visited.add(start);
    
    while (queue.length > 0) {
        const node = queue.shift();
        console.log(node);  // Process node
        
        // Visit all neighbors
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
}

// Example graph (adjacency list)
const graph = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E']
};

bfs(graph, 'A');  // A, B, C, D, E, F`,
                infoCards: [
                    { title: '‚è±Ô∏è Complexity', text: 'Time: O(V + E) where V = vertices, E = edges. Space: O(V) for queue.' },
                    { title: '‚úÖ Pros', text: 'Finds shortest path (unweighted). Explores level by level. Complete search.' },
                    { title: 'üéØ Best Use Cases', text: 'Shortest path. Level-order traversal. Connected components. Nearest neighbor.' }
                ]
            },
            'dfs': {
                title: 'DFS Traversal',
                icon: '‚¨áÔ∏è',
                timeComplexity: 'O(V + E)',
                spaceComplexity: 'O(V)',
                description: `
                    <p><span class="highlight">Depth-First Search (DFS)</span> explores as far as possible 
                    along each branch before backtracking.</p>
                    
                    <p>Uses a <span class="highlight">stack</span> (or recursion) to track the path. 
                    Great for detecting cycles, topological sorting, and solving mazes.</p>
                `,
                steps: [
                    'Start from source, push to stack',
                    'While stack not empty:',
                    '  - Pop a node, process it',
                    '  - Push all unvisited neighbors',
                    '  - Mark as visited',
                    'Backtrack when no unvisited neighbors'
                ],
                code: `// Recursive DFS
function dfsRecursive(graph, node, visited = new Set()) {
    visited.add(node);
    console.log(node);  // Process node
    
    for (const neighbor of graph[node]) {
        if (!visited.has(neighbor)) {
            dfsRecursive(graph, neighbor, visited);
        }
    }
}

// Iterative DFS with stack
function dfsIterative(graph, start) {
    const visited = new Set();
    const stack = [start];
    
    while (stack.length > 0) {
        const node = stack.pop();
        
        if (!visited.has(node)) {
            visited.add(node);
            console.log(node);
            
            // Push neighbors (reverse for correct order)
            for (const n of graph[node].reverse()) {
                if (!visited.has(n)) {
                    stack.push(n);
                }
            }
        }
    }
}`,
                infoCards: [
                    { title: '‚è±Ô∏è Complexity', text: 'Time: O(V + E). Space: O(V) for stack/recursion depth.' },
                    { title: '‚úÖ Pros', text: 'Uses less memory than BFS for wide graphs. Good for deep exploration.' },
                    { title: 'üéØ Best Use Cases', text: 'Cycle detection. Topological sort. Path finding. Maze solving. Backtracking.' }
                ]
            },
            'graph-basics': {
                title: 'Graph Basics',
                icon: 'üåê',
                timeComplexity: 'Varies',
                spaceComplexity: 'O(V + E)',
                description: `
                    <p>A <span class="highlight">Graph</span> is a collection of <span class="highlight">vertices (nodes)</span> 
                    connected by <span class="highlight">edges</span>. Unlike trees, graphs can have cycles and multiple paths.</p>
                    
                    <p><span class="highlight">Directed</span>: Edges have direction (A ‚Üí B). 
                    <span class="highlight">Undirected</span>: Edges go both ways (A ‚Äî B).</p>
                    
                    <p>Two main representations: <span class="highlight">Adjacency Matrix</span> (2D array) and 
                    <span class="highlight">Adjacency List</span> (array of lists).</p>
                `,
                steps: [
                    'Vertices: The nodes in the graph',
                    'Edges: Connections between nodes',
                    'Directed vs Undirected graphs',
                    'Weighted vs Unweighted edges',
                    'Adjacency Matrix: O(V¬≤) space, O(1) edge lookup',
                    'Adjacency List: O(V+E) space, O(degree) edge lookup'
                ],
                code: `// Adjacency List representation
const graph = {
    A: ['B', 'C'],
    B: ['A', 'D'],
    C: ['A', 'D'],
    D: ['B', 'C']
};

// Adjacency Matrix representation
//     A  B  C  D
// A [ 0, 1, 1, 0 ]
// B [ 1, 0, 0, 1 ]
// C [ 1, 0, 0, 1 ]
// D [ 0, 1, 1, 0 ]

// Graph class with adjacency list
class Graph {
    constructor() {
        this.adjacencyList = {};
    }
    
    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }
    
    addEdge(v1, v2) {
        this.adjacencyList[v1].push(v2);
        this.adjacencyList[v2].push(v1); // Remove for directed
    }
}`,
                infoCards: [
                    { title: 'üìä Representations', text: 'Matrix: Good for dense graphs. List: Good for sparse graphs (most real-world graphs).' },
                    { title: 'üî¢ Terminology', text: 'Degree: edges per vertex. Path: sequence of vertices. Cycle: path that returns to start.' },
                    { title: 'üéØ Applications', text: 'Social networks. Maps/GPS. Web crawling. Dependencies. Network routing.' }
                ]
            },
            'dijkstra': {
                title: "Dijkstra's Algorithm",
                icon: 'üõ§Ô∏è',
                timeComplexity: 'O((V+E) log V)',
                spaceComplexity: 'O(V)',
                description: `
                    <p><span class="highlight">Dijkstra's Algorithm</span> finds the shortest path from a source vertex 
                    to all other vertices in a <span class="highlight">weighted graph with non-negative weights</span>.</p>
                    
                    <p>It uses a <span class="highlight">greedy approach</span>: always process the unvisited vertex 
                    with the smallest known distance, then update distances to its neighbors.</p>
                    
                    <p>Pro tip: Use a <span class="highlight">Priority Queue (Min-Heap)</span> for optimal O((V+E) log V) time.</p>
                `,
                steps: [
                    'Set distance to source = 0, all others = ‚àû',
                    'Add source to priority queue',
                    'Extract vertex with minimum distance',
                    'For each neighbor: if new path shorter, update',
                    'Add updated neighbors to queue',
                    'Repeat until all vertices processed'
                ],
                code: `function dijkstra(graph, start) {
    const distances = {};
    const visited = new Set();
    const pq = new MinPriorityQueue();
    
    // Initialize distances
    for (const vertex in graph) {
        distances[vertex] = Infinity;
    }
    distances[start] = 0;
    pq.enqueue(start, 0);
    
    while (!pq.isEmpty()) {
        const { element: current } = pq.dequeue();
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        for (const [neighbor, weight] of graph[current]) {
            const newDist = distances[current] + weight;
            
            if (newDist < distances[neighbor]) {
                distances[neighbor] = newDist;
                pq.enqueue(neighbor, newDist);
            }
        }
    }
    
    return distances;
}

// Graph with weights: { A: [[B, 4], [C, 2]], ... }`,
                infoCards: [
                    { title: '‚è±Ô∏è Complexity', text: 'With min-heap: O((V+E) log V). With array: O(V¬≤). Space: O(V).' },
                    { title: '‚ö†Ô∏è Limitations', text: 'Does NOT work with negative weights! Use Bellman-Ford for negative edges.' },
                    { title: 'üéØ Best Use Cases', text: 'GPS navigation. Network routing. Game pathfinding. Social network analysis.' }
                ]
            },
            'grid-pathfinding': {
                title: 'Grid Pathfinding (A*)',
                icon: 'üó∫Ô∏è',
                timeComplexity: 'O(b^d)',
                spaceComplexity: 'O(b^d)',
                description: `
                    <p>Pathfinding on a 2D grid is a core problem in game development and robotics. We want to find the 
                    shortest path from <span class="highlight">Start (green)</span> to <span class="highlight">End (red)</span> 
                    while avoiding <span class="highlight">Walls (white)</span>.</p>
                    
                    <p>Common Algorithms:</p>
                    <ul>
                        <li><span class="highlight">BFS</span>: Guarantees shortest path (unweighted). Explores equally in all directions.</li>
                        <li><span class="highlight">Dijkstra</span>: Guarantees shortest path (weighted). Prioritizes lower cost.</li>
                        <li><span class="highlight">A* (A-Star)</span>: Smartest! Uses a <span class="highlight">Heuristic (h)</span> to estimate distance to target. f(n) = g(n) + h(n).</li>
                    </ul>
                `,
                steps: [
                    'Initialize grid with Start, End, and Walls',
                    'A* Logic: Open Set (candidates), Closed Set (visited)',
                    'Calculate scores: g (distance from start), h (distance to end)',
                    'Pick node with lowest f = g + h',
                    'Trace path back from End to Start using "parent" pointers'
                ],
                code: `// A* Heuristic (Manhattan Distance)
function heuristic(a, b) {
    return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);
}

// A* Main Loop
while (openSet.length > 0) {
    // 1. Get node with lowest 'f' score
    let winner = 0;
    for (let i = 0; i < openSet.length; i++) {
        if (openSet[i].f < openSet[winner].f) winner = i;
    }
    let current = openSet[winner];

    // 2. Check if reached end
    if (current === end) {
        return reconstructPath(current);
    }
    
    // 3. Move current from Open to Closed
    removeFromArray(openSet, current);
    closedSet.push(current);

    // 4. Check neighbors
    for (let neighbor of current.neighbors) {
        if (!closedSet.includes(neighbor) && !neighbor.wall) {
            let tempG = current.g + 1;
            
            if (openSet.includes(neighbor)) {
                if (tempG < neighbor.g) neighbor.g = tempG;
            } else {
                neighbor.g = tempG;
                openSet.push(neighbor);
            }
            
            neighbor.h = heuristic(neighbor, end);
            neighbor.f = neighbor.g + neighbor.h;
            neighbor.previous = current;
        }
    }
}`,
                infoCards: [
                    { title: 'üß† A* Heuristic', text: 'Euclidean (straight line) or Manhattan (grid steps) distance drives the search towards the goal.' },
                    { title: 'üÜö BFS vs A*', text: 'BFS explores blindly (circle). A* explores intelligently (arrow). BFS is O(V+E), A* is faster.' },
                    { title: 'üéÆ Use Cases', text: 'RTS unit movement. RPG character navigation. Robot vacuum cleaning paths.' }
                ]
            },
            'dp-fib': {
                title: 'DP (Fibonacci)',
                icon: 'üî¢',
                timeComplexity: 'O(n)',
                spaceComplexity: 'O(n)',
                description: `
                    <p>Dynamic Programming (DP) is an optimization technique where we solve complex problems by breaking them down into 
                    simpler subproblems and storing their results (<span class="highlight">Memoization</span>) to avoid redundant work.</p>
                    
                    <p>The <strong>Fibonacci Sequence</strong> is the classic example:</p>
                    <ul>
                        <li><span class="highlight">Naive Recursion</span>: O(2^n). Recalculates same values (e.g., fib(3)) many times. Tree grows exponentially.</li>
                        <li><span class="highlight">DP (Memoization)</span>: O(n). Stores result of fib(i) first time it's computed. Future calls are O(1).</li>
                    </ul>
                `,
                steps: [
                    'Define Base Cases: fib(0)=0, fib(1)=1',
                    'Recursive Step: fib(n) = fib(n-1) + fib(n-2)',
                    'Check Memo: If memo[n] exists, return it immediately',
                    'Store Result: Save fib(n) in memo before returning'
                ],
                code: `// Naive Recursion (Slow)
function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}

// Dynamic Programming (Fast)
let memo = {};
function fibDP(n) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;
    
    memo[n] = fibDP(n - 1) + fibDP(n - 2);
    return memo[n];
}`,
                infoCards: [
                    { title: 'üöÄ Speedup', text: 'For n=50, recursion takes ~1000 years. DP takes < 1 millisecond. Exponential vs Linear.' },
                    { title: 'üß† Core Concept', text: 'Overlapping Subproblems + Optimal Substructure. If a problem has these, use DP.' },
                    { title: 'üìö Variants', text: 'Top-Down (Memoization) vs Bottom-Up (Tabulation). Both are O(n) for Fibonacci.' }
                ]
            },
            'dp-knapsack': {
                title: '0/1 Knapsack',
                icon: 'üéí',
                timeComplexity: 'O(n√óW)',
                spaceComplexity: 'O(n√óW)',
                description: `
                    <p>The <span class="highlight">0/1 Knapsack Problem</span>: Given n items with weights and values, 
                    find the maximum value that fits in a knapsack of capacity W.</p>
                    
                    <p><strong>Key Insight</strong>: For each item, you have 2 choices:</p>
                    <ul>
                        <li><span class="highlight">Include it</span>: Add its value, reduce remaining capacity</li>
                        <li><span class="highlight">Exclude it</span>: Skip to next item, keep capacity</li>
                    </ul>
                    <p>Build a 2D table where dp[i][w] = max value using first i items with capacity w.</p>
                `,
                steps: [
                    'Create 2D table dp[n+1][W+1], initialize with 0',
                    'For each item i from 1 to n:',
                    '  For each capacity w from 0 to W:',
                    '    If weight[i] > w: dp[i][w] = dp[i-1][w] (skip)',
                    '    Else: dp[i][w] = max(dp[i-1][w], value[i] + dp[i-1][w-weight[i]])',
                    'Answer is dp[n][W]'
                ],
                code: `function knapsack(weights, values, W) {
    const n = weights.length;
    const dp = Array(n + 1).fill(null)
        .map(() => Array(W + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= W; w++) {
            // Don't take item i
            dp[i][w] = dp[i-1][w];
            
            // Take item i (if it fits)
            if (weights[i-1] <= w) {
                const take = values[i-1] + dp[i-1][w - weights[i-1]];
                dp[i][w] = Math.max(dp[i][w], take);
            }
        }
    }
    
    return dp[n][W];
}

// Example: weights=[2,3,4], values=[3,4,5], W=5
// Answer: 7 (items 1 and 2)`,
                infoCards: [
                    { title: 'üéØ Applications', text: 'Resource allocation, budget optimization, cargo loading, investment portfolios.' },
                    { title: 'üîÑ Variants', text: 'Unbounded Knapsack (infinite items), Fractional Knapsack (greedy), Subset Sum.' },
                    { title: 'üí° Space Optimization', text: 'Can reduce to O(W) space by using 1D array and iterating backwards.' }
                ]
            },
            'dp-lcs': {
                title: 'Longest Common Subsequence',
                icon: 'üîó',
                timeComplexity: 'O(m√ón)',
                spaceComplexity: 'O(m√ón)',
                description: `
                    <p>The <span class="highlight">Longest Common Subsequence (LCS)</span> problem finds the longest 
                    subsequence present in both strings. A subsequence maintains relative order but need not be contiguous.</p>
                    
                    <p><strong>Example</strong>: LCS of "ABCDGH" and "AEDFHR" is "ADH" (length 3).</p>
                    
                    <p><strong>Key Insight</strong>: Compare characters from end:</p>
                    <ul>
                        <li>If <span class="highlight">match</span>: 1 + LCS of remaining prefixes</li>
                        <li>If <span class="highlight">no match</span>: max(skip char from s1, skip char from s2)</li>
                    </ul>
                `,
                steps: [
                    'Create 2D table dp[m+1][n+1], initialize with 0',
                    'For each i from 1 to m:',
                    '  For each j from 1 to n:',
                    '    If s1[i-1] == s2[j-1]: dp[i][j] = 1 + dp[i-1][j-1]',
                    '    Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])',
                    'Answer is dp[m][n]'
                ],
                code: `function lcs(s1, s2) {
    const m = s1.length, n = s2.length;
    const dp = Array(m + 1).fill(null)
        .map(() => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s1[i-1] === s2[j-1]) {
                dp[i][j] = 1 + dp[i-1][j-1];
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}

// Example: lcs("ABCDGH", "AEDFHR") = 3 ("ADH")`,
                infoCards: [
                    { title: 'üìù Applications', text: 'Diff tools (git diff), DNA sequence alignment, spell checkers, plagiarism detection.' },
                    { title: 'üîÑ Related Problems', text: 'Longest Common Substring (contiguous), Edit Distance, Shortest Common Supersequence.' },
                    { title: 'üîç Backtracking', text: 'Trace back through dp table to reconstruct the actual LCS string.' }
                ]
            },
            'dp-coin': {
                title: 'Coin Change',
                icon: 'ü™ô',
                timeComplexity: 'O(n√óamount)',
                spaceComplexity: 'O(amount)',
                description: `
                    <p>The <span class="highlight">Coin Change Problem</span>: Given coins of different denominations and a total amount, 
                    find the minimum number of coins needed to make that amount.</p>
                    
                    <p><strong>Key Insight</strong>: For each amount, try every coin and take the minimum:</p>
                    <ul>
                        <li>dp[amount] = min(dp[amount], 1 + dp[amount - coin])</li>
                        <li>Base case: dp[0] = 0 (0 coins needed for amount 0)</li>
                    </ul>
                `,
                steps: [
                    'Create array dp[amount+1], initialize with Infinity',
                    'Set dp[0] = 0 (base case)',
                    'For each amount from 1 to target:',
                    '  For each coin denomination:',
                    '    If coin <= amount: dp[amount] = min(dp[amount], 1 + dp[amount-coin])',
                    'Return dp[target] (or -1 if Infinity)'
                ],
                code: `function coinChange(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;  // Base case
    
    for (let a = 1; a <= amount; a++) {
        for (const coin of coins) {
            if (coin <= a) {
                dp[a] = Math.min(dp[a], 1 + dp[a - coin]);
            }
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
}

// Example: coinChange([1,2,5], 11) = 3 (5+5+1)`,
                infoCards: [
                    { title: 'üéØ Variants', text: 'Count ways to make change (sum instead of min), Unbounded vs 0/1 versions.' },
                    { title: 'üí° Greedy Fails', text: 'Greedy (pick largest coin first) doesn\'t always work. E.g., coins=[1,3,4], amount=6.' },
                    { title: 'üìä Interview Favorite', text: 'Top 10 most asked DP problem at FAANG companies.' }
                ]
            },
            'n-queens': {
                title: 'N-Queens Problem',
                icon: '‚ôõ',
                timeComplexity: 'O(N!)',
                spaceComplexity: 'O(N¬≤)',
                description: `
                    <p>The <span class="highlight">N-Queens Problem</span>: Place N queens on an N√óN chessboard so that no two queens 
                    attack each other (no same row, column, or diagonal).</p>
                    
                    <p><strong>Backtracking Approach</strong>:</p>
                    <ul>
                        <li>Place queens <span class="highlight">row by row</span></li>
                        <li>For each row, try each column</li>
                        <li>Check if placement is <span class="highlight">safe</span> (no conflicts)</li>
                        <li>If stuck, <span class="highlight">backtrack</span> and try next column</li>
                    </ul>
                `,
                steps: [
                    'Start with empty board, row 0',
                    'Try placing queen in each column of current row',
                    'Check if position is safe (no queen attacks)',
                    'If safe: place queen, move to next row (recurse)',
                    'If all columns fail: backtrack (remove queen, return false)',
                    'If row == N: solution found!'
                ],
                code: `function solveNQueens(n) {
    const board = Array(n).fill(null).map(() => Array(n).fill('.'));
    const solutions = [];
    
    function isSafe(row, col) {
        // Check column above
        for (let i = 0; i < row; i++) {
            if (board[i][col] === 'Q') return false;
        }
        // Check upper-left diagonal
        for (let i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] === 'Q') return false;
        }
        // Check upper-right diagonal
        for (let i = row-1, j = col+1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] === 'Q') return false;
        }
        return true;
    }
    
    function backtrack(row) {
        if (row === n) {
            solutions.push(board.map(r => r.join('')));
            return;
        }
        for (let col = 0; col < n; col++) {
            if (isSafe(row, col)) {
                board[row][col] = 'Q';
                backtrack(row + 1);
                board[row][col] = '.';  // Backtrack
            }
        }
    }
    
    backtrack(0);
    return solutions;
}`,
                infoCards: [
                    { title: 'üìä Solutions Count', text: 'N=4: 2 solutions. N=8: 92 solutions. N=12: 14,200 solutions!' },
                    { title: 'üîÑ Optimizations', text: 'Use bit manipulation for O(1) conflict checks. Exploit symmetry to halve search.' },
                    { title: 'üéØ Classic Interview', text: 'Tests recursion, backtracking, and 2D array manipulation skills.' }
                ]
            },
            'sudoku-solver': {
                title: 'Sudoku Solver',
                icon: 'üß©',
                timeComplexity: 'O(9^(n*n))',
                spaceComplexity: 'O(n¬≤)',
                description: `
                    <p>The <span class="highlight">Sudoku Solver</span> uses backtracking to fill a 9√ó9 grid 
                    so that each row, column, and 3√ó3 box contains digits 1-9 exactly once.</p>
                    
                    <p><strong>Backtracking Strategy</strong>:</p>
                    <ul>
                        <li>Find an <span class="highlight">empty cell</span></li>
                        <li>Try digits 1-9 that are <span class="highlight">valid</span></li>
                        <li>If valid, place digit and <span class="highlight">recurse</span></li>
                        <li>If no valid digit works, <span class="highlight">backtrack</span></li>
                    </ul>
                `,
                steps: [
                    'Find the next empty cell (with value 0)',
                    'Try placing digits 1 through 9',
                    'Check if digit is valid (not in same row, column, or 3√ó3 box)',
                    'If valid: place digit and recurse to next empty cell',
                    'If recursion fails: remove digit (backtrack) and try next',
                    'If no valid digit: return false (trigger backtrack)',
                    'If no empty cells left: puzzle solved!'
                ],
                code: `function solveSudoku(board) {
    function isValid(board, row, col, num) {
        // Check row
        for (let x = 0; x < 9; x++) {
            if (board[row][x] === num) return false;
        }
        // Check column
        for (let x = 0; x < 9; x++) {
            if (board[x][col] === num) return false;
        }
        // Check 3x3 box
        let boxRow = Math.floor(row / 3) * 3;
        let boxCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[boxRow + i][boxCol + j] === num) {
                    return false;
                }
            }
        }
        return true;
    }
    
    function solve() {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === 0) {
                    for (let num = 1; num <= 9; num++) {
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (solve()) return true;
                            board[row][col] = 0; // Backtrack
                        }
                    }
                    return false; // No valid number found
                }
            }
        }
        return true; // All cells filled
    }
    
    solve();
    return board;
}`,
                infoCards: [
                    { title: 'üî¢ Constraints', text: 'Each row, column, and 3√ó3 box must contain 1-9 exactly once. No duplicates allowed!' },
                    { title: '‚ö° Optimizations', text: 'Use constraint propagation, naked singles, hidden singles before brute force backtracking.' },
                    { title: 'üß† Difficulty Levels', text: 'Easy: 35+ givens. Medium: 27-35. Hard: 22-27. Expert: 17-22 (minimum is 17!)' }
                ]
            },
            'maze-solver': {
                title: 'Maze Solver',
                icon: 'üß≠',
                timeComplexity: 'O(2^(n¬≤))',
                spaceComplexity: 'O(n¬≤)',
                description: `
                    <p>The <span class="highlight">Maze Solver</span> (Rat in a Maze) uses backtracking to find 
                    a path from the top-left to bottom-right of a grid, avoiding walls.</p>
                    
                    <p><strong>Backtracking Strategy</strong>:</p>
                    <ul>
                        <li>Start from <span class="highlight">(0, 0)</span></li>
                        <li>Try moving in each direction (Down, Right, Up, Left)</li>
                        <li>Mark cell as part of <span class="highlight">path</span></li>
                        <li>If dead end, <span class="highlight">unmark and backtrack</span></li>
                    </ul>
                `,
                steps: [
                    'Start at position (0, 0)',
                    'Mark current cell as part of solution path',
                    'If at destination (n-1, n-1): path found!',
                    'Try each direction: Down, Right, Up, Left',
                    'For each valid move (in bounds, not wall, not visited): recurse',
                    'If all directions fail: unmark cell and return false',
                    'Path gradually builds through valid cells'
                ],
                code: `function solveMaze(maze) {
    const n = maze.length;
    const solution = Array(n).fill(null).map(() => Array(n).fill(0));
    
    function isSafe(x, y) {
        return x >= 0 && x < n && y >= 0 && y < n 
               && maze[x][y] === 1 && solution[x][y] === 0;
    }
    
    function solve(x, y) {
        // Reached destination
        if (x === n - 1 && y === n - 1) {
            solution[x][y] = 1;
            return true;
        }
        
        if (isSafe(x, y)) {
            solution[x][y] = 1; // Mark as path
            
            // Try Down
            if (solve(x + 1, y)) return true;
            // Try Right
            if (solve(x, y + 1)) return true;
            // Try Up
            if (solve(x - 1, y)) return true;
            // Try Left
            if (solve(x, y - 1)) return true;
            
            // Backtrack: unmark cell
            solution[x][y] = 0;
            return false;
        }
        return false;
    }
    
    if (solve(0, 0)) return solution;
    return null; // No path exists
}

// maze: 1 = open, 0 = wall`,
                infoCards: [
                    { title: 'üéØ Directions', text: 'Common order: Down, Right, Up, Left (DRUL). Order affects which path is found first.' },
                    { title: 'üîÑ vs BFS/DFS', text: 'Backtracking finds A path, not shortest. Use BFS for shortest path in unweighted maze.' },
                    { title: 'üéÆ Applications', text: 'Game AI pathfinding, robot navigation, puzzle games, escape room algorithms.' }
                ]
            }
        };

        // Current visualization sketch
        let currentSketch = null;

        // Render topic content
        function renderTopic(topicId) {
            const topic = TOPICS[topicId];
            if (!topic) {
                document.getElementById('content').innerHTML = '<p>Topic coming soon...</p>';
                return;
            }

            const stepsHtml = topic.steps.map((s, i) => `<li>${s}</li>`).join('');
            const cardsHtml = topic.infoCards.map(c => `
                <div class="info-card">
                    <h5>${c.title}</h5>
                    <p>${c.text}</p>
                </div>
            `).join('');

            document.getElementById('content').innerHTML = `
                <div class="topic-header">
                    <h1>${topic.icon} ${topic.title}</h1>
                    <div class="complexity-badges">
                        <span class="badge badge-time">‚è±Ô∏è Time: ${topic.timeComplexity}</span>
                        <span class="badge badge-space">üíæ Space: ${topic.spaceComplexity}</span>
                    </div>
                </div>

                <div class="viz-container">
                    <div class="viz-header">
                        <span class="viz-title">üì∫ Interactive Visualization</span>
                        <div class="viz-controls">
                            <div class="speed-control">
                                <label>Speed:</label>
                                <input type="range" id="speedSlider" min="1" max="5" value="3">
                            </div>
                            <button class="viz-btn viz-btn-secondary" onclick="resetViz()">‚Ü∫ Reset</button>
                            <button class="viz-btn viz-btn-primary" onclick="startViz()">‚ñ∂ Start</button>
                        </div>
                    </div>
                    <div class="viz-canvas" id="vizCanvas"></div>
                </div>

                <section class="theory-section">
                    <h2 class="section-title">üìñ How It Works</h2>
                    <div class="theory-content">
                        ${topic.description}
                        
                        <div class="steps-box">
                            <h4>üìù Step-by-Step Process</h4>
                            <ol>${stepsHtml}</ol>
                        </div>
                    </div>
                </section>

                <section class="code-section">
                    <h2 class="section-title">üíª JavaScript Implementation</h2>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                        </div>
                        <pre class="code-content">${highlightCode(topic.code)}</pre>
                    </div>
                </section>

                <section class="theory-section">
                    <h2 class="section-title">üìä Analysis</h2>
                    <div class="info-grid">${cardsHtml}</div>
                </section>
            `;

            // Initialize visualization
            initVisualization(topicId);
        }

        // Simple syntax highlighting
        function highlightCode(code) {
            return code
                .replace(/\b(function|let|const|var|for|if|return|break)\b/g, '<span class="keyword">$1</span>')
                .replace(/\b(\d+)\b/g, '<span class="number">$1</span>')
                .replace(/(\/\/.*)/g, '<span class="comment">$1</span>');
        }

        // Visualization sketches
        function initVisualization(topicId) {
            if (currentSketch) {
                currentSketch.remove();
            }

            if (topicId === 'bubble-sort') {
                currentSketch = new p5(bubbleSortSketch, 'vizCanvas');
            } else if (topicId === 'selection-sort') {
                currentSketch = new p5(selectionSortSketch, 'vizCanvas');
            } else if (topicId === 'insertion-sort') {
                currentSketch = new p5(insertionSortSketch, 'vizCanvas');
            } else if (topicId === 'merge-sort') {
                currentSketch = new p5(mergeSortSketch, 'vizCanvas');
            } else if (topicId === 'quick-sort') {
                currentSketch = new p5(quickSortSketch, 'vizCanvas');
            } else if (topicId === 'linear-search') {
                currentSketch = new p5(linearSearchSketch, 'vizCanvas');
            } else if (topicId === 'binary-search') {
                currentSketch = new p5(binarySearchSketch, 'vizCanvas');
            } else if (topicId === 'arrays') {
                currentSketch = new p5(arraySketch, 'vizCanvas');
            } else if (topicId === 'stack') {
                currentSketch = new p5(stackSketch, 'vizCanvas');
            } else if (topicId === 'queue') {
                currentSketch = new p5(queueSketch, 'vizCanvas');
            } else if (topicId === 'linked-list') {
                currentSketch = new p5(linkedListSketch, 'vizCanvas');
            } else if (topicId === 'hash-table') {
                currentSketch = new p5(hashTableSketch, 'vizCanvas');
            } else if (topicId === 'binary-tree' || topicId === 'bst') {
                currentSketch = new p5(binaryTreeSketch, 'vizCanvas');
            } else if (topicId === 'preorder') {
                currentSketch = new p5(preorderSketch, 'vizCanvas');
            } else if (topicId === 'inorder') {
                currentSketch = new p5(inorderSketch, 'vizCanvas');
            } else if (topicId === 'postorder') {
                currentSketch = new p5(postorderSketch, 'vizCanvas');
            } else if (topicId === 'bfs') {
                currentSketch = new p5(bfsSketch, 'vizCanvas');
            } else if (topicId === 'dfs') {
                currentSketch = new p5(dfsSketch, 'vizCanvas');
            } else if (topicId === 'graph-basics') {
                currentSketch = new p5(graphBasicsSketch, 'vizCanvas');
            } else if (topicId === 'dijkstra') {
                currentSketch = new p5(dijkstraSketch, 'vizCanvas');
            } else if (topicId === 'heap-sort') {
                currentSketch = new p5(heapSortSketch, 'vizCanvas');
            } else if (topicId === 'heap') {
                currentSketch = new p5(heapSketch, 'vizCanvas');
            } else if (topicId === 'grid-pathfinding') {
                currentSketch = new p5(gridPathfindingSketch, 'vizCanvas');
            } else if (topicId === 'dp-fib') {
                currentSketch = new p5(dpFibSketch, 'vizCanvas');
            } else if (topicId === 'dp-knapsack') {
                currentSketch = new p5(dpKnapsackSketch, 'vizCanvas');
            } else if (topicId === 'dp-lcs') {
                currentSketch = new p5(dpLcsSketch, 'vizCanvas');
            } else if (topicId === 'dp-coin') {
                currentSketch = new p5(dpCoinSketch, 'vizCanvas');
            } else if (topicId === 'n-queens') {
                currentSketch = new p5(nQueensSketch, 'vizCanvas');
            } else if (topicId === 'sudoku-solver') {
                currentSketch = new p5(sudokuSketch, 'vizCanvas');
            } else if (topicId === 'maze-solver') {
                currentSketch = new p5(mazeSketch, 'vizCanvas');
            }
        }

        // Bubble Sort Visualization
        let bubbleSortSketch = function (p) {
            let arr = [];
            let i = 0, j = 0;
            let sorting = false;
            let sorted = false;
            const W = 600, H = 280;
            let barWidth;

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                arr = [];
                for (let k = 0; k < 25; k++) {
                    arr.push({
                        value: p.random(30, H - 30),
                        state: 'default'
                    });
                }
                barWidth = (W - 40) / arr.length;
                i = 0;
                j = 0;
                sorting = false;
                sorted = false;
            }

            window.resetViz = resetArray;
            window.startViz = function () {
                if (sorted) resetArray();
                sorting = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw bars
                for (let k = 0; k < arr.length; k++) {
                    let x = 20 + k * barWidth;
                    let h = arr[k].value;

                    // Color based on state
                    if (k === j && sorting) {
                        p.fill(255, 170, 0);
                    } else if (k === j + 1 && sorting) {
                        p.fill(255, 100, 100);
                    } else if (sorted || k >= arr.length - i) {
                        p.fill(0, 255, 136);
                    } else {
                        let c = p.lerpColor(p.color(68, 136, 255), p.color(100, 180, 255), h / H);
                        p.fill(c);
                    }

                    p.noStroke();
                    p.rect(x, H - h, barWidth - 3, h, 4);
                }

                // Sorting logic
                let speed = document.getElementById('speedSlider')?.value || 3;
                if (sorting && p.frameCount % (6 - speed) === 0) {
                    if (i < arr.length - 1) {
                        if (j < arr.length - i - 1) {
                            if (arr[j].value > arr[j + 1].value) {
                                let temp = arr[j];
                                arr[j] = arr[j + 1];
                                arr[j + 1] = temp;
                            }
                            j++;
                        } else {
                            j = 0;
                            i++;
                        }
                    } else {
                        sorting = false;
                        sorted = true;
                    }
                }

                // Status text
                p.fill(100);
                p.textSize(12);
                p.textAlign(p.CENTER);
                if (!sorting && !sorted) {
                    p.text('Click "Start" to begin sorting', W / 2, 20);
                } else if (sorting) {
                    p.text(`Pass ${i + 1} / ${arr.length - 1}  |  Comparing index ${j} and ${j + 1}`, W / 2, 20);
                } else {
                    p.fill(0, 255, 136);
                    p.text('‚úì Sorted!', W / 2, 20);
                }
            };
        };

        // Selection Sort Visualization
        let selectionSortSketch = function (p) {
            let arr = [];
            let i = 0, j = 0, minIdx = 0;
            let sorting = false;
            let sorted = false;
            const W = 600, H = 280;
            let barWidth;

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                arr = [];
                for (let k = 0; k < 25; k++) {
                    arr.push({ value: p.random(30, H - 30) });
                }
                barWidth = (W - 40) / arr.length;
                i = 0; j = 1; minIdx = 0;
                sorting = false;
                sorted = false;
            }

            window.resetViz = resetArray;
            window.startViz = function () {
                if (sorted) resetArray();
                sorting = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                for (let k = 0; k < arr.length; k++) {
                    let x = 20 + k * barWidth;
                    let h = arr[k].value;

                    if (k < i) {
                        p.fill(0, 255, 136); // Sorted
                    } else if (k === minIdx && sorting) {
                        p.fill(255, 100, 100); // Current minimum
                    } else if (k === j && sorting) {
                        p.fill(255, 170, 0); // Comparing
                    } else if (k === i && sorting) {
                        p.fill(100, 200, 255); // Current position
                    } else if (sorted) {
                        p.fill(0, 255, 136);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, H - h, barWidth - 3, h, 4);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (sorting && p.frameCount % (6 - speed) === 0) {
                    if (i < arr.length - 1) {
                        if (j < arr.length) {
                            if (arr[j].value < arr[minIdx].value) {
                                minIdx = j;
                            }
                            j++;
                        } else {
                            // Swap
                            if (minIdx !== i) {
                                let temp = arr[i];
                                arr[i] = arr[minIdx];
                                arr[minIdx] = temp;
                            }
                            i++;
                            j = i + 1;
                            minIdx = i;
                        }
                    } else {
                        sorting = false;
                        sorted = true;
                    }
                }

                p.fill(100);
                p.textSize(12);
                p.textAlign(p.CENTER);
                if (!sorting && !sorted) {
                    p.text('Click "Start" to begin sorting', W / 2, 20);
                } else if (sorting) {
                    p.text(`Finding minimum in positions ${i} to ${arr.length - 1}  |  Current min at index ${minIdx}`, W / 2, 20);
                } else {
                    p.fill(0, 255, 136);
                    p.text('‚úì Sorted!', W / 2, 20);
                }
            };
        };

        // Insertion Sort Visualization
        let insertionSortSketch = function (p) {
            let arr = [];
            let i = 1, j = 0;
            let key = 0;
            let sorting = false;
            let sorted = false;
            let phase = 'compare'; // 'compare' or 'shift'
            const W = 600, H = 280;
            let barWidth;

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                arr = [];
                for (let k = 0; k < 25; k++) {
                    arr.push({ value: p.random(30, H - 30) });
                }
                barWidth = (W - 40) / arr.length;
                i = 1; j = 0; key = 0;
                sorting = false;
                sorted = false;
                phase = 'compare';
            }

            window.resetViz = resetArray;
            window.startViz = function () {
                if (sorted) resetArray();
                sorting = true;
                key = arr[i].value;
                j = i - 1;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                for (let k = 0; k < arr.length; k++) {
                    let x = 20 + k * barWidth;
                    let h = arr[k].value;

                    if (k < i && !sorting) {
                        p.fill(0, 255, 136); // Sorted
                    } else if (k === j + 1 && sorting) {
                        p.fill(255, 170, 0); // Key position
                    } else if (k === j && sorting) {
                        p.fill(255, 100, 100); // Comparing
                    } else if (sorted) {
                        p.fill(0, 255, 136);
                    } else if (k < i) {
                        p.fill(100, 200, 255); // Sorted portion
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, H - h, barWidth - 3, h, 4);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (sorting && p.frameCount % (6 - speed) === 0) {
                    if (j >= 0 && arr[j].value > key) {
                        arr[j + 1].value = arr[j].value;
                        j--;
                    } else {
                        arr[j + 1].value = key;
                        i++;
                        if (i < arr.length) {
                            key = arr[i].value;
                            j = i - 1;
                        } else {
                            sorting = false;
                            sorted = true;
                        }
                    }
                }

                p.fill(100);
                p.textSize(12);
                p.textAlign(p.CENTER);
                if (!sorting && !sorted) {
                    p.text('Click "Start" to begin sorting', W / 2, 20);
                } else if (sorting) {
                    p.text(`Inserting element ${i}  |  Key value: ${Math.round(key)}  |  Checking position ${j + 1}`, W / 2, 20);
                } else {
                    p.fill(0, 255, 136);
                    p.text('‚úì Sorted!', W / 2, 20);
                }
            };
        };

        // Merge Sort Visualization (simplified iterative version for animation)
        let mergeSortSketch = function (p) {
            let arr = [];
            let sorting = false;
            let sorted = false;
            let size = 1;
            let leftStart = 0;
            let merging = false;
            let left = [], right = [], merged = [];
            let mergeIdx = 0;
            const W = 600, H = 280;
            let barWidth;

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                arr = [];
                for (let k = 0; k < 25; k++) {
                    arr.push({ value: p.random(30, H - 30), group: 0 });
                }
                barWidth = (W - 40) / arr.length;
                size = 1;
                leftStart = 0;
                sorting = false;
                sorted = false;
                merging = false;
            }

            window.resetViz = resetArray;
            window.startViz = function () {
                if (sorted) resetArray();
                sorting = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                for (let k = 0; k < arr.length; k++) {
                    let x = 20 + k * barWidth;
                    let h = arr[k].value;

                    // Color by group/position
                    if (sorted) {
                        p.fill(0, 255, 136);
                    } else if (k >= leftStart && k < leftStart + size && sorting) {
                        p.fill(255, 170, 0); // Left part
                    } else if (k >= leftStart + size && k < leftStart + 2 * size && sorting) {
                        p.fill(255, 100, 100); // Right part
                    } else {
                        let hue = (k / arr.length) * 100;
                        p.fill(68 + hue, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, H - h, barWidth - 3, h, 4);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (sorting && p.frameCount % (8 - speed) === 0) {
                    // Bottom-up merge sort step
                    if (size < arr.length) {
                        if (leftStart < arr.length) {
                            let mid = Math.min(leftStart + size, arr.length);
                            let end = Math.min(leftStart + 2 * size, arr.length);

                            // Merge arr[leftStart..mid) and arr[mid..end)
                            let l = leftStart, r = mid, temp = [];
                            while (l < mid && r < end) {
                                if (arr[l].value <= arr[r].value) {
                                    temp.push(arr[l++]);
                                } else {
                                    temp.push(arr[r++]);
                                }
                            }
                            while (l < mid) temp.push(arr[l++]);
                            while (r < end) temp.push(arr[r++]);

                            for (let t = 0; t < temp.length; t++) {
                                arr[leftStart + t] = temp[t];
                            }

                            leftStart += 2 * size;
                        } else {
                            leftStart = 0;
                            size *= 2;
                        }
                    } else {
                        sorting = false;
                        sorted = true;
                    }
                }

                p.fill(100);
                p.textSize(12);
                p.textAlign(p.CENTER);
                if (!sorting && !sorted) {
                    p.text('Click "Start" to see Merge Sort in action', W / 2, 20);
                } else if (sorting) {
                    p.text(`Merge size: ${size}  |  Merging at position ${leftStart}`, W / 2, 20);
                } else {
                    p.fill(0, 255, 136);
                    p.text('‚úì Sorted!', W / 2, 20);
                }
            };
        };

        // Quick Sort Visualization
        let quickSortSketch = function (p) {
            let arr = [];
            let sorting = false;
            let sorted = false;
            let stack = [];
            let low = 0, high = 0, pivotIdx = -1, i = 0, j = 0;
            let phase = 'idle';
            const W = 600, H = 280;
            let barWidth;

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                arr = [];
                for (let k = 0; k < 25; k++) {
                    arr.push({ value: p.random(30, H - 30), sorted: false });
                }
                barWidth = (W - 40) / arr.length;
                stack = [];
                sorting = false;
                sorted = false;
                phase = 'idle';
            }

            window.resetViz = resetArray;
            window.startViz = function () {
                if (sorted) resetArray();
                sorting = true;
                stack = [[0, arr.length - 1]];
                phase = 'partition';
            };

            p.draw = function () {
                p.background(10, 10, 18);

                for (let k = 0; k < arr.length; k++) {
                    let x = 20 + k * barWidth;
                    let h = arr[k].value;

                    if (arr[k].sorted || sorted) {
                        p.fill(0, 255, 136);
                    } else if (k === high && sorting) {
                        p.fill(255, 100, 100); // Pivot
                    } else if (k === j && sorting) {
                        p.fill(255, 170, 0); // Current
                    } else if (k >= low && k <= high && sorting) {
                        p.fill(100, 180, 255); // In range
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, H - h, barWidth - 3, h, 4);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (sorting && p.frameCount % (6 - speed) === 0) {
                    if (stack.length > 0) {
                        if (phase === 'partition') {
                            [low, high] = stack[stack.length - 1];
                            if (low < high) {
                                i = low - 1;
                                j = low;
                                pivotIdx = high;
                                phase = 'comparing';
                            } else {
                                if (low === high) arr[low].sorted = true;
                                stack.pop();
                            }
                        } else if (phase === 'comparing') {
                            if (j < high) {
                                if (arr[j].value < arr[pivotIdx].value) {
                                    i++;
                                    [arr[i], arr[j]] = [arr[j], arr[i]];
                                }
                                j++;
                            } else {
                                // Place pivot
                                i++;
                                [arr[i], arr[high]] = [arr[high], arr[i]];
                                arr[i].sorted = true;

                                stack.pop();
                                if (i + 1 < high) stack.push([i + 1, high]);
                                if (low < i - 1) stack.push([low, i - 1]);

                                phase = 'partition';
                            }
                        }
                    } else {
                        sorting = false;
                        sorted = true;
                        arr.forEach(a => a.sorted = true);
                    }
                }

                p.fill(100);
                p.textSize(12);
                p.textAlign(p.CENTER);
                if (!sorting && !sorted) {
                    p.text('Click "Start" to see Quick Sort partition the array', W / 2, 20);
                } else if (sorting) {
                    p.text(`Partitioning [${low}..${high}]  |  Pivot value: ${Math.round(arr[pivotIdx]?.value || 0)}`, W / 2, 20);
                } else {
                    p.fill(0, 255, 136);
                    p.text('‚úì Sorted!', W / 2, 20);
                }
            };
        };

        // Linear Search Visualization
        let linearSearchSketch = function (p) {
            let arr = [];
            let target = 0;
            let currentIdx = -1;
            let searching = false;
            let found = false;
            let notFound = false;
            const W = 600, H = 280;
            let boxSize;

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                arr = [];
                for (let k = 0; k < 15; k++) {
                    arr.push(Math.floor(p.random(1, 100)));
                }
                target = arr[Math.floor(p.random(arr.length))];
                boxSize = (W - 60) / arr.length;
                currentIdx = -1;
                searching = false;
                found = false;
                notFound = false;
            }

            window.resetViz = resetArray;
            window.startViz = function () {
                if (found || notFound) resetArray();
                currentIdx = 0;
                searching = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw boxes
                for (let k = 0; k < arr.length; k++) {
                    let x = 30 + k * boxSize;
                    let y = H / 2 - 30;

                    if (found && k === currentIdx) {
                        p.fill(0, 255, 136);
                    } else if (k === currentIdx && searching) {
                        p.fill(255, 170, 0);
                    } else if (k < currentIdx) {
                        p.fill(80, 80, 100);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, y, boxSize - 4, 60, 8);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text(arr[k], x + boxSize / 2 - 2, y + 30);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (searching && p.frameCount % (12 - speed * 2) === 0) {
                    if (arr[currentIdx] === target) {
                        found = true;
                        searching = false;
                    } else if (currentIdx < arr.length - 1) {
                        currentIdx++;
                    } else {
                        notFound = true;
                        searching = false;
                    }
                }

                p.fill(100);
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text(`Target: ${target}`, W / 2, 40);

                if (!searching && !found && !notFound) {
                    p.text('Click "Start" to search', W / 2, H - 30);
                } else if (searching) {
                    p.text(`Checking index ${currentIdx}...`, W / 2, H - 30);
                } else if (found) {
                    p.fill(0, 255, 136);
                    p.text(`‚úì Found at index ${currentIdx}!`, W / 2, H - 30);
                } else {
                    p.fill(255, 100, 100);
                    p.text('‚úó Not found in array', W / 2, H - 30);
                }
            };
        };

        // Binary Search Visualization
        let binarySearchSketch = function (p) {
            let arr = [];
            let target = 0;
            let left = 0, right = 0, mid = 0;
            let searching = false;
            let found = false;
            let notFound = false;
            const W = 600, H = 280;
            let boxSize;

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                arr = [];
                for (let k = 0; k < 15; k++) {
                    arr.push(k * 7 + Math.floor(p.random(1, 5)));
                }
                target = arr[Math.floor(p.random(arr.length))];
                boxSize = (W - 60) / arr.length;
                left = 0;
                right = arr.length - 1;
                mid = Math.floor((left + right) / 2);
                searching = false;
                found = false;
                notFound = false;
            }

            window.resetViz = resetArray;
            window.startViz = function () {
                if (found || notFound) resetArray();
                left = 0;
                right = arr.length - 1;
                mid = Math.floor((left + right) / 2);
                searching = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                for (let k = 0; k < arr.length; k++) {
                    let x = 30 + k * boxSize;
                    let y = H / 2 - 30;

                    if (found && k === mid) {
                        p.fill(0, 255, 136);
                    } else if (k === mid && searching) {
                        p.fill(255, 170, 0);
                    } else if (k >= left && k <= right && searching) {
                        p.fill(100, 180, 255);
                    } else if (k < left || k > right) {
                        p.fill(50, 50, 60);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, y, boxSize - 4, 60, 8);

                    p.fill(k >= left && k <= right ? 255 : 100);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(14);
                    p.text(arr[k], x + boxSize / 2 - 2, y + 30);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (searching && p.frameCount % (15 - speed * 2) === 0) {
                    if (arr[mid] === target) {
                        found = true;
                        searching = false;
                    } else if (left > right) {
                        notFound = true;
                        searching = false;
                    } else if (arr[mid] < target) {
                        left = mid + 1;
                        mid = Math.floor((left + right) / 2);
                    } else {
                        right = mid - 1;
                        mid = Math.floor((left + right) / 2);
                    }
                }

                p.fill(100);
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text(`Target: ${target}  |  Range: [${left}...${right}]  |  Mid: ${mid}`, W / 2, 40);

                if (!searching && !found && !notFound) {
                    p.text('Click "Start" to search (sorted array)', W / 2, H - 30);
                } else if (searching) {
                    p.text(`Checking middle: arr[${mid}] = ${arr[mid]}`, W / 2, H - 30);
                } else if (found) {
                    p.fill(0, 255, 136);
                    p.text(`‚úì Found at index ${mid}!`, W / 2, H - 30);
                } else {
                    p.fill(255, 100, 100);
                    p.text('‚úó Not found', W / 2, H - 30);
                }
            };
        };

        // Array Visualization
        let arraySketch = function (p) {
            let arr = [10, 25, 8, 42, 17, 33, 5];
            let highlightIdx = -1;
            let animating = false;
            let action = '';
            const W = 600, H = 280;
            let boxSize = 60;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            function reset() {
                arr = [10, 25, 8, 42, 17, 33, 5];
                highlightIdx = -1;
                animating = false;
            }

            window.resetViz = reset;
            window.startViz = function () {
                if (!animating) {
                    animating = true;
                    highlightIdx = 0;
                    action = 'access';
                }
            };

            p.draw = function () {
                p.background(10, 10, 18);

                let startX = (W - arr.length * boxSize) / 2;

                for (let i = 0; i < arr.length; i++) {
                    let x = startX + i * boxSize;

                    if (i === highlightIdx) {
                        p.fill(255, 170, 0);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, H / 2 - 30, boxSize - 4, 60, 8);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(18);
                    p.text(arr[i], x + boxSize / 2 - 2, H / 2);

                    p.fill(100);
                    p.textSize(11);
                    p.text(i, x + boxSize / 2 - 2, H / 2 + 45);
                }

                if (animating && p.frameCount % 20 === 0) {
                    highlightIdx++;
                    if (highlightIdx >= arr.length) {
                        highlightIdx = -1;
                        animating = false;
                    }
                }

                p.fill(100);
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text('Array: Random access O(1) by index', W / 2, 40);
                if (highlightIdx >= 0) {
                    p.fill(255, 170, 0);
                    p.text(`Accessing arr[${highlightIdx}] = ${arr[highlightIdx]}`, W / 2, H - 30);
                }
            };
        };

        // Stack Visualization
        let stackSketch = function (p) {
            let stack = [10, 20, 30];
            let animating = false;
            let action = '';
            const W = 600, H = 280;
            const boxH = 40;
            const boxW = 80;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                stack = [10, 20, 30];
                animating = false;
            };
            window.startViz = function () {
                if (stack.length < 7) {
                    stack.push(Math.floor(p.random(1, 100)));
                    action = 'push';
                } else {
                    stack.pop();
                    action = 'pop';
                }
            };

            p.draw = function () {
                p.background(10, 10, 18);

                let baseY = H - 50;
                for (let i = 0; i < stack.length; i++) {
                    let y = baseY - i * boxH;

                    if (i === stack.length - 1) {
                        p.fill(0, 255, 136);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(W / 2 - boxW / 2, y - boxH, boxW, boxH - 4, 6);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text(stack[i], W / 2, y - boxH / 2 - 2);
                }

                // Top pointer
                if (stack.length > 0) {
                    let topY = baseY - (stack.length - 1) * boxH - boxH / 2;
                    p.fill(0, 255, 136);
                    p.text('‚Üê TOP', W / 2 + boxW / 2 + 30, topY);
                }

                p.fill(100);
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text('Stack: LIFO (Last In, First Out)', W / 2, 30);
                p.text('Click "Start" to Push/Pop elements', W / 2, 55);
            };
        };

        // Queue Visualization
        let queueSketch = function (p) {
            let queue = [10, 20, 30];
            const W = 600, H = 280;
            const boxW = 60;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                queue = [10, 20, 30];
            };
            window.startViz = function () {
                if (queue.length < 8) {
                    queue.push(Math.floor(p.random(1, 100)));
                } else {
                    queue.shift();
                }
            };

            p.draw = function () {
                p.background(10, 10, 18);

                let startX = (W - queue.length * boxW) / 2;

                for (let i = 0; i < queue.length; i++) {
                    let x = startX + i * boxW;

                    if (i === 0) {
                        p.fill(255, 100, 100);
                    } else if (i === queue.length - 1) {
                        p.fill(0, 255, 136);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.rect(x, H / 2 - 25, boxW - 4, 50, 6);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text(queue[i], x + boxW / 2 - 2, H / 2);
                }

                if (queue.length > 0) {
                    p.fill(255, 100, 100);
                    p.textSize(12);
                    p.text('FRONT ‚Üì', startX + boxW / 2, H / 2 - 45);
                    p.fill(0, 255, 136);
                    p.text('BACK ‚Üì', startX + (queue.length - 0.5) * boxW, H / 2 - 45);
                }

                p.fill(100);
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text('Queue: FIFO (First In, First Out)', W / 2, 30);
                p.text('Click "Start" to Enqueue/Dequeue', W / 2, H - 40);
            };
        };

        // Linked List Visualization
        let linkedListSketch = function (p) {
            let nodes = [10, 20, 30, 40];
            const W = 600, H = 280;
            const boxW = 60;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                nodes = [10, 20, 30, 40];
            };
            window.startViz = function () {
                if (nodes.length < 7) {
                    nodes.push(Math.floor(p.random(1, 100)));
                } else {
                    nodes.shift();
                }
            };

            p.draw = function () {
                p.background(10, 10, 18);

                let startX = 50;
                let y = H / 2;
                let gap = (W - 100) / Math.max(nodes.length, 1);

                for (let i = 0; i < nodes.length; i++) {
                    let x = startX + i * gap;

                    // Draw node box
                    p.fill(68, 136, 255);
                    p.noStroke();
                    p.rect(x, y - 25, boxW, 50, 6);

                    // Draw pointer section
                    p.fill(40, 80, 150);
                    p.rect(x + boxW - 15, y - 25, 15, 50, 0, 6, 6, 0);

                    // Value
                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text(nodes[i], x + (boxW - 15) / 2, y);

                    // Arrow
                    if (i < nodes.length - 1) {
                        p.stroke(0, 255, 136);
                        p.strokeWeight(2);
                        p.line(x + boxW, y, x + gap - 5, y);
                        p.noStroke();
                        p.fill(0, 255, 136);
                        p.triangle(x + gap - 5, y - 6, x + gap - 5, y + 6, x + gap + 5, y);
                    }
                }

                // Head label
                p.fill(0, 255, 136);
                p.textSize(12);
                p.textAlign(p.CENTER);
                p.text('HEAD', startX + boxW / 2, y - 45);

                // Null at end
                if (nodes.length > 0) {
                    let lastX = startX + (nodes.length - 1) * gap + boxW + 20;
                    p.fill(100);
                    p.text('null', lastX + 15, y);
                }

                p.fill(100);
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text('Linked List: Nodes connected by pointers', W / 2, 30);
                p.text('Click "Start" to Add/Remove nodes', W / 2, H - 30);
            };
        };

        // Hash Table Visualization
        let hashTableSketch = function (p) {
            let buckets = [
                [['name', 'Alice']],
                [],
                [['age', 25], ['city', 'NYC']],
                [],
                [['job', 'Dev']],
                [],
                []
            ];
            let highlightBucket = -1;
            const W = 600, H = 280;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                buckets = [
                    [['name', 'Alice']],
                    [],
                    [['age', 25], ['city', 'NYC']],
                    [],
                    [['job', 'Dev']],
                    [],
                    []
                ];
                highlightBucket = -1;
            };

            window.startViz = function () {
                const keys = ['email', 'phone', 'id', 'role', 'status'];
                const key = keys[Math.floor(p.random(keys.length))];
                const val = Math.floor(p.random(100));
                const idx = Math.abs(key.split('').reduce((a, c) => a + c.charCodeAt(0), 0)) % 7;
                buckets[idx].push([key, val]);
                highlightBucket = idx;
                if (buckets[idx].length > 3) buckets[idx].shift();
            };

            p.draw = function () {
                p.background(10, 10, 18);

                const bucketH = 35;
                const bucketW = 80;
                const startX = 40;
                const startY = 60;

                // Draw buckets
                for (let i = 0; i < buckets.length; i++) {
                    let y = startY + i * bucketH;

                    // Index
                    p.fill(100);
                    p.textSize(12);
                    p.textAlign(p.RIGHT, p.CENTER);
                    p.text(i, startX - 10, y + bucketH / 2);

                    // Bucket box
                    if (i === highlightBucket) {
                        p.fill(0, 255, 136, 50);
                        p.stroke(0, 255, 136);
                    } else {
                        p.fill(30, 30, 45);
                        p.stroke(60, 60, 80);
                    }
                    p.strokeWeight(1);
                    p.rect(startX, y, bucketW, bucketH - 4, 4);

                    // Items in bucket
                    let itemX = startX + bucketW + 10;
                    for (let j = 0; j < buckets[i].length; j++) {
                        const [k, v] = buckets[i][j];

                        if (i === highlightBucket && j === buckets[i].length - 1) {
                            p.fill(0, 255, 136);
                        } else {
                            p.fill(68, 136, 255);
                        }
                        p.noStroke();
                        p.rect(itemX, y + 2, 70, bucketH - 8, 4);

                        p.fill(255);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(10);
                        p.text(`${k}:${v}`, itemX + 35, y + bucketH / 2 - 2);

                        itemX += 75;
                    }
                }

                p.noStroke();
                p.fill(100);
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text('Hash Table: Key ‚Üí Hash ‚Üí Bucket Index', W / 2, 25);
                p.textSize(12);
                p.text('Click "Start" to add key-value pairs', W / 2, H - 15);
            };
        };

        // Binary Tree Visualization
        let binaryTreeSketch = function (p) {
            const nodes = [
                { val: 10, x: 300, y: 50 },
                { val: 5, x: 150, y: 120 },
                { val: 15, x: 450, y: 120 },
                { val: 3, x: 80, y: 190 },
                { val: 7, x: 220, y: 190 },
                { val: 12, x: 380, y: 190 },
                { val: 20, x: 520, y: 190 }
            ];
            const edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]];

            // Three traversal orders
            const traversals = {
                'Pre-order': [0, 1, 3, 4, 2, 5, 6],   // Root ‚Üí Left ‚Üí Right
                'In-order': [3, 1, 4, 0, 5, 2, 6],    // Left ‚Üí Root ‚Üí Right
                'Post-order': [3, 4, 1, 5, 6, 2, 0]   // Left ‚Üí Right ‚Üí Root
            };
            const traversalNames = ['Pre-order', 'In-order', 'Post-order'];
            let currentTraversal = 0;

            let visitedIdx = -1;
            let traversing = false;
            let order = [];
            let traversalName = '';
            const W = 600, H = 280;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                visitedIdx = -1;
                traversing = false;
                order = [];
            };

            window.startViz = function () {
                traversalName = traversalNames[currentTraversal];
                order = traversals[traversalName];
                visitedIdx = 0;
                traversing = true;
                currentTraversal = (currentTraversal + 1) % 3;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw edges
                p.stroke(60, 60, 80);
                p.strokeWeight(2);
                for (const [i, j] of edges) {
                    p.line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                }

                // Draw nodes
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const visited = order.slice(0, visitedIdx + 1).includes(i);

                    if (traversing && order[visitedIdx] === i) {
                        p.fill(255, 170, 0);
                    } else if (visited) {
                        p.fill(0, 255, 136);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.circle(n.x, n.y, 40);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(14);
                    p.text(n.val, n.x, n.y);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (traversing && p.frameCount % (20 - speed * 3) === 0) {
                    visitedIdx++;
                    if (visitedIdx >= order.length) {
                        traversing = false;
                    }
                }

                p.fill(100);
                p.textSize(13);
                p.textAlign(p.CENTER);

                if (traversing || order.length > 0) {
                    const desc = traversalName === 'Pre-order' ? 'Root ‚Üí Left ‚Üí Right' :
                        traversalName === 'In-order' ? 'Left ‚Üí Root ‚Üí Right' :
                            'Left ‚Üí Right ‚Üí Root';
                    p.text(`${traversalName}: ${desc}  |  Order: [${order.slice(0, visitedIdx + 1).map(i => nodes[i].val).join(', ')}]`, W / 2, H - 15);
                } else {
                    p.text('Click "Start" to see traversals (Pre ‚Üí In ‚Üí Post)', W / 2, H - 15);
                }
            };
        };

        // Helper function to create traversal sketch
        function createTraversalSketch(traversalOrder, traversalName, traversalDesc) {
            return function (p) {
                const nodes = [
                    { val: 10, x: 300, y: 50 },
                    { val: 5, x: 150, y: 120 },
                    { val: 15, x: 450, y: 120 },
                    { val: 3, x: 80, y: 190 },
                    { val: 7, x: 220, y: 190 },
                    { val: 12, x: 380, y: 190 },
                    { val: 20, x: 520, y: 190 }
                ];
                const edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]];
                let visitedIdx = -1;
                let traversing = false;
                const W = 600, H = 280;

                p.setup = function () {
                    p.createCanvas(W, H);
                };

                window.resetViz = function () {
                    visitedIdx = -1;
                    traversing = false;
                };

                window.startViz = function () {
                    visitedIdx = 0;
                    traversing = true;
                };

                p.draw = function () {
                    p.background(10, 10, 18);

                    // Draw edges
                    p.stroke(60, 60, 80);
                    p.strokeWeight(2);
                    for (const [i, j] of edges) {
                        p.line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                    }

                    // Draw nodes
                    for (let i = 0; i < nodes.length; i++) {
                        const n = nodes[i];
                        const visited = traversalOrder.slice(0, visitedIdx + 1).includes(i);

                        if (traversing && traversalOrder[visitedIdx] === i) {
                            p.fill(255, 170, 0);
                        } else if (visited) {
                            p.fill(0, 255, 136);
                        } else {
                            p.fill(68, 136, 255);
                        }

                        p.noStroke();
                        p.circle(n.x, n.y, 40);

                        p.fill(255);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(14);
                        p.text(n.val, n.x, n.y);
                    }

                    let speed = document.getElementById('speedSlider')?.value || 3;
                    if (traversing && p.frameCount % (20 - speed * 3) === 0) {
                        visitedIdx++;
                        if (visitedIdx >= traversalOrder.length) {
                            traversing = false;
                            visitedIdx = traversalOrder.length - 1;
                        }
                    }

                    p.fill(100);
                    p.textSize(13);
                    p.textAlign(p.CENTER);

                    const orderedVals = traversalOrder.slice(0, Math.max(0, visitedIdx + 1)).map(i => nodes[i].val);
                    p.text(`${traversalName}: ${traversalDesc}`, W / 2, 25);
                    if (orderedVals.length > 0) {
                        p.fill(0, 255, 136);
                        p.text(`Order: [${orderedVals.join(', ')}]`, W / 2, H - 15);
                    } else {
                        p.text('Click "Start" to visualize', W / 2, H - 15);
                    }
                };
            };
        }

        // Pre-order: Root ‚Üí Left ‚Üí Right (10, 5, 3, 7, 15, 12, 20)
        let preorderSketch = createTraversalSketch([0, 1, 3, 4, 2, 5, 6], 'Pre-order', 'Root ‚Üí Left ‚Üí Right');

        // In-order: Left ‚Üí Root ‚Üí Right (3, 5, 7, 10, 12, 15, 20)
        let inorderSketch = createTraversalSketch([3, 1, 4, 0, 5, 2, 6], 'In-order', 'Left ‚Üí Root ‚Üí Right');

        // Post-order: Left ‚Üí Right ‚Üí Root (3, 7, 5, 12, 20, 15, 10)
        let postorderSketch = createTraversalSketch([3, 4, 1, 5, 6, 2, 0], 'Post-order', 'Left ‚Üí Right ‚Üí Root');

        // BFS Visualization
        let bfsSketch = function (p) {
            const nodes = [
                { id: 'A', x: 100, y: 140 },
                { id: 'B', x: 200, y: 60 },
                { id: 'C', x: 200, y: 220 },
                { id: 'D', x: 350, y: 60 },
                { id: 'E', x: 350, y: 140 },
                { id: 'F', x: 350, y: 220 },
                { id: 'G', x: 500, y: 140 }
            ];
            const edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [4, 6], [5, 6]];
            let visited = [];
            let queue = [];
            let traversing = false;
            const W = 600, H = 280;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                visited = [];
                queue = [];
                traversing = false;
            };

            window.startViz = function () {
                visited = [];
                queue = [0];
                traversing = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw edges
                p.stroke(60, 60, 80);
                p.strokeWeight(2);
                for (const [i, j] of edges) {
                    p.line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                }

                // Draw nodes
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];

                    if (queue.length > 0 && queue[0] === i) {
                        p.fill(255, 170, 0); // Current
                    } else if (visited.includes(i)) {
                        p.fill(0, 255, 136); // Visited
                    } else if (queue.includes(i)) {
                        p.fill(100, 180, 255); // In queue
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.circle(n.x, n.y, 45);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text(n.id, n.x, n.y);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (traversing && p.frameCount % (25 - speed * 4) === 0) {
                    if (queue.length > 0) {
                        const curr = queue.shift();
                        visited.push(curr);

                        for (const [i, j] of edges) {
                            if (i === curr && !visited.includes(j) && !queue.includes(j)) {
                                queue.push(j);
                            }
                            if (j === curr && !visited.includes(i) && !queue.includes(i)) {
                                queue.push(i);
                            }
                        }
                    } else {
                        traversing = false;
                    }
                }

                p.fill(100);
                p.textSize(13);
                p.textAlign(p.CENTER);
                p.text(`BFS: Queue = [${queue.map(i => nodes[i]?.id).join(', ')}]  |  Visited = [${visited.map(i => nodes[i].id).join(', ')}]`, W / 2, H - 15);
            };
        };

        // DFS Visualization
        let dfsSketch = function (p) {
            const nodes = [
                { id: 'A', x: 100, y: 140 },
                { id: 'B', x: 200, y: 60 },
                { id: 'C', x: 200, y: 220 },
                { id: 'D', x: 350, y: 60 },
                { id: 'E', x: 350, y: 140 },
                { id: 'F', x: 350, y: 220 },
                { id: 'G', x: 500, y: 140 }
            ];
            const edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [4, 6], [5, 6]];
            let visited = [];
            let stack = [];
            let traversing = false;
            const W = 600, H = 280;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                visited = [];
                stack = [];
                traversing = false;
            };

            window.startViz = function () {
                visited = [];
                stack = [0];
                traversing = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw edges
                p.stroke(60, 60, 80);
                p.strokeWeight(2);
                for (const [i, j] of edges) {
                    p.line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                }

                // Draw nodes
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];

                    if (stack.length > 0 && stack[stack.length - 1] === i) {
                        p.fill(255, 170, 0); // Current (top of stack)
                    } else if (visited.includes(i)) {
                        p.fill(0, 255, 136); // Visited
                    } else if (stack.includes(i)) {
                        p.fill(170, 100, 255); // In stack
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.circle(n.x, n.y, 45);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text(n.id, n.x, n.y);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (traversing && p.frameCount % (25 - speed * 4) === 0) {
                    if (stack.length > 0) {
                        const curr = stack.pop();
                        if (!visited.includes(curr)) {
                            visited.push(curr);

                            for (const [i, j] of edges) {
                                if (i === curr && !visited.includes(j)) {
                                    stack.push(j);
                                }
                                if (j === curr && !visited.includes(i)) {
                                    stack.push(i);
                                }
                            }
                        }
                    } else {
                        traversing = false;
                    }
                }

                p.fill(100);
                p.textSize(13);
                p.textAlign(p.CENTER);
                p.text(`DFS: Stack = [${stack.map(i => nodes[i]?.id).join(', ')}]  |  Visited = [${visited.map(i => nodes[i].id).join(', ')}]`, W / 2, H - 15);
            };
        };

        // Graph Basics Visualization
        let graphBasicsSketch = function (p) {
            const nodes = [
                { id: 'A', x: 100, y: 100 },
                { id: 'B', x: 250, y: 60 },
                { id: 'C', x: 400, y: 100 },
                { id: 'D', x: 150, y: 200 },
                { id: 'E', x: 350, y: 200 },
                { id: 'F', x: 500, y: 150 }
            ];
            const edges = [[0, 1], [0, 3], [1, 2], [1, 4], [2, 5], [3, 4], [4, 5]];
            let hoverNode = -1;
            const W = 600, H = 280;

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () { hoverNode = -1; };
            window.startViz = function () { };

            p.draw = function () {
                p.background(10, 10, 18);

                // Find hover
                hoverNode = -1;
                for (let i = 0; i < nodes.length; i++) {
                    if (p.dist(p.mouseX, p.mouseY, nodes[i].x, nodes[i].y) < 25) {
                        hoverNode = i;
                    }
                }

                // Draw edges
                for (const [i, j] of edges) {
                    if (hoverNode === i || hoverNode === j) {
                        p.stroke(0, 255, 136);
                        p.strokeWeight(3);
                    } else {
                        p.stroke(60, 60, 80);
                        p.strokeWeight(2);
                    }
                    p.line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                }

                // Draw nodes
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];

                    if (hoverNode === i) {
                        p.fill(0, 255, 136);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.circle(n.x, n.y, 45);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text(n.id, n.x, n.y);
                }

                p.fill(100);
                p.textSize(13);
                p.textAlign(p.CENTER);
                p.text('Graph: Vertices connected by Edges (Hover to highlight connections)', W / 2, 25);

                if (hoverNode >= 0) {
                    const neighbors = edges.filter(([i, j]) => i === hoverNode || j === hoverNode)
                        .map(([i, j]) => nodes[i === hoverNode ? j : i].id);
                    p.fill(0, 255, 136);
                    p.text(`Node ${nodes[hoverNode].id} ‚Üí Neighbors: [${neighbors.join(', ')}]`, W / 2, H - 15);
                }
            };
        };

        // Dijkstra's Algorithm Visualization
        let dijkstraSketch = function (p) {
            const nodes = [
                { id: 'A', x: 80, y: 140 },
                { id: 'B', x: 200, y: 60 },
                { id: 'C', x: 200, y: 220 },
                { id: 'D', x: 350, y: 60 },
                { id: 'E', x: 350, y: 220 },
                { id: 'F', x: 500, y: 140 }
            ];
            // [from, to, weight]
            const edges = [
                [0, 1, 4], [0, 2, 2],
                [1, 3, 3], [1, 4, 1],
                [2, 4, 5],
                [3, 5, 2],
                [4, 5, 3]
            ];
            let distances = {};
            let visited = [];
            let current = -1;
            let running = false;
            let queue = [];
            const W = 600, H = 280;

            p.setup = function () {
                p.createCanvas(W, H);
                reset();
            };

            function reset() {
                distances = { A: 0, B: Infinity, C: Infinity, D: Infinity, E: Infinity, F: Infinity };
                visited = [];
                current = -1;
                running = false;
                queue = [0];
            }

            window.resetViz = reset;
            window.startViz = function () {
                reset();
                running = true;
            };

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw edges with weights
                for (const [i, j, w] of edges) {
                    p.stroke(60, 60, 80);
                    p.strokeWeight(2);
                    p.line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);

                    // Weight label
                    const mx = (nodes[i].x + nodes[j].x) / 2;
                    const my = (nodes[i].y + nodes[j].y) / 2;
                    p.fill(255, 200, 100);
                    p.noStroke();
                    p.circle(mx, my, 20);
                    p.fill(0);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(11);
                    p.text(w, mx, my);
                }

                // Draw nodes
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];

                    if (current === i) {
                        p.fill(255, 170, 0);
                    } else if (visited.includes(i)) {
                        p.fill(0, 255, 136);
                    } else {
                        p.fill(68, 136, 255);
                    }

                    p.noStroke();
                    p.circle(n.x, n.y, 45);

                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(14);
                    const dist = distances[n.id];
                    p.text(n.id, n.x, n.y - 6);
                    p.textSize(10);
                    p.text(dist === Infinity ? '‚àû' : dist, n.x, n.y + 10);
                }

                let speed = document.getElementById('speedSlider')?.value || 3;
                if (running && p.frameCount % (30 - speed * 5) === 0) {
                    if (queue.length > 0) {
                        // Find min distance node in queue
                        let minIdx = 0;
                        for (let i = 1; i < queue.length; i++) {
                            if (distances[nodes[queue[i]].id] < distances[nodes[queue[minIdx]].id]) {
                                minIdx = i;
                            }
                        }
                        current = queue.splice(minIdx, 1)[0];
                        visited.push(current);

                        // Update neighbors
                        for (const [i, j, w] of edges) {
                            let neighbor = -1;
                            if (i === current) neighbor = j;
                            if (j === current) neighbor = i;

                            if (neighbor >= 0 && !visited.includes(neighbor)) {
                                const newDist = distances[nodes[current].id] + w;
                                if (newDist < distances[nodes[neighbor].id]) {
                                    distances[nodes[neighbor].id] = newDist;
                                }
                                if (!queue.includes(neighbor)) queue.push(neighbor);
                            }
                        }
                    } else {
                        running = false;
                        current = -1;
                    }
                }

                p.fill(100);
                p.textSize(13);
                p.textAlign(p.CENTER);
                p.text("Dijkstra's: Finding shortest paths from A (numbers = edge weights)", W / 2, 25);
                p.fill(100);
                p.textSize(13);
                p.textAlign(p.CENTER);
                p.text("Dijkstra's: Finding shortest paths from A (numbers = edge weights)", W / 2, 25);
            };
        };

        // Heap Sort Visualization
        let heapSortSketch = function (p) {
            let arr = [];
            const W = 600, H = 280;
            let barWidth;
            let abort = false; // Flag to stop running animations

            p.setup = function () {
                p.createCanvas(W, H);
                resetArray();
            };

            function resetArray() {
                abort = true; // Stop any ongoing sort
                setTimeout(() => {
                    abort = false;
                    arr = [];
                    for (let k = 0; k < 25; k++) {
                        arr.push({
                            value: p.floor(p.random(10, H - 30)),
                            state: 'default' // default, compare, swap, sorted
                        });
                    }
                    barWidth = (W - 40) / arr.length;
                }, 100);
            }

            // Promise-based sleep that respects speed slider
            const sleep = (ms) => new Promise(resolve => {
                let speed = document.getElementById('speedSlider')?.value || 3;
                let actualMs = ms / Math.max(1, (speed * 0.8)); // Speed 5 is faster
                if (speed >= 5) actualMs = 10;
                setTimeout(resolve, actualMs);
            });

            window.resetViz = async function () {
                abort = true;
                await sleep(100);

                arr = [];
                for (let k = 0; k < 25; k++) {
                    arr.push({
                        value: p.floor(p.random(10, H - 30)),
                        state: 'default'
                    });
                }
                barWidth = (W - 40) / arr.length;
                abort = false;
            };

            window.startViz = async function () {
                // Always reset if already running or sorted
                await window.resetViz();

                // Phase 1: Build Max Heap
                for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
                    if (abort) return;
                    await heapify(arr.length, i);
                }

                // Phase 2: Extract elements
                for (let i = arr.length - 1; i > 0; i--) {
                    if (abort) return;

                    // Swap root with end
                    await swap(0, i);
                    arr[i].state = 'sorted';

                    // Heapify root
                    await heapify(i, 0);
                }
                arr[0].state = 'sorted';
            };

            async function swap(i, j) {
                if (abort) return;
                arr[i].state = 'swap';
                arr[j].state = 'swap';
                await sleep(300);

                let temp = arr[i].value;
                arr[i].value = arr[j].value;
                arr[j].value = temp;

                // Restore colors (unless sorted)
                if (arr[i].state !== 'sorted') arr[i].state = 'default';
                if (arr[j].state !== 'sorted') arr[j].state = 'default';
            }

            async function heapify(n, i) {
                if (abort) return;

                let largest = i;
                let left = 2 * i + 1;
                let right = 2 * i + 2;

                // Highlight comparison
                if (left < n) {
                    arr[left].state = 'compare';
                    arr[largest].state = 'compare';
                }
                if (right < n) arr[right].state = 'compare';
                await sleep(200);

                if (left < n && arr[left].value > arr[largest].value) largest = left;
                if (right < n && arr[right].value > arr[largest].value) largest = right;

                // Reset comparison highlight
                if (arr[i].state !== 'sorted') arr[i].state = 'default';
                if (left < n && arr[left].state !== 'sorted') arr[left].state = 'default';
                if (right < n && arr[right].state !== 'sorted') arr[right].state = 'default';

                if (largest !== i) {
                    await swap(i, largest);
                    await heapify(n, largest);
                }
            }

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw bars
                for (let k = 0; k < arr.length; k++) {
                    if (arr[k].state === 'sorted') p.fill(0, 255, 136);
                    else if (arr[k].state === 'swap') p.fill(255, 50, 50);
                    else if (arr[k].state === 'compare') p.fill(255, 170, 0);
                    else p.fill(68, 136, 255);

                    p.rect(20 + k * barWidth, H - arr[k].value, barWidth - 2, arr[k].value);
                }

                p.fill(100);
                p.textSize(12);
                p.textAlign(p.CENTER);
                let msg = 'Heap Sort: Building Max Heap -> Extracting Max';
                if (arr.length > 0 && arr[0].state === 'sorted') msg = 'Sorted!';
                if (abort) msg = 'Resetting...';
                p.text(msg, W / 2, 20);
            };
        };

        // Heap Data Structure Visualization
        let heapSketch = function (p) {
            let heap = [];
            const W = 600, H = 280;
            let message = "Click Start to add random numbers";

            p.setup = function () {
                p.createCanvas(W, H);
            };

            window.resetViz = function () {
                heap = [];
                message = "Click Start to add random numbers";
            };

            window.startViz = function () {
                // Add a random number
                if (heap.length < 15) {
                    insert(Math.floor(p.random(10, 99)));
                } else {
                    message = "Heap full! Reset to start over.";
                }
            };

            // Add extract min button functionality via clicking canvas?
            // Or just auto-demo? Let's make Start add, and clicking remove.
            p.mousePressed = function () {
                if (p.mouseX > 0 && p.mouseX < W && p.mouseY > 0 && p.mouseY < H) {
                    if (heap.length > 0) {
                        extractMin();
                        message = "Extracted Min!";
                    }
                }
            };

            function insert(val) {
                heap.push(val);
                bubbleUp();
                message = `Inserted ${val}`;
            }

            function bubbleUp() {
                let index = heap.length - 1;
                while (index > 0) {
                    let parentIndex = Math.floor((index - 1) / 2);
                    if (heap[parentIndex] <= heap[index]) break;
                    [heap[parentIndex], heap[index]] = [heap[index], heap[parentIndex]];
                    index = parentIndex;
                }
            }

            function extractMin() {
                const min = heap[0];
                const last = heap.pop();
                if (heap.length > 0) {
                    heap[0] = last;
                    sinkDown();
                }
                return min;
            }

            function sinkDown() {
                let idx = 0;
                const length = heap.length;
                while (true) {
                    let leftIdx = 2 * idx + 1;
                    let rightIdx = 2 * idx + 2;
                    let swap = null;

                    if (leftIdx < length) {
                        if (heap[leftIdx] < heap[idx]) swap = leftIdx;
                    }
                    if (rightIdx < length) {
                        if ((swap === null && heap[rightIdx] < heap[idx]) ||
                            (swap !== null && heap[rightIdx] < heap[leftIdx])) {
                            swap = rightIdx;
                        }
                    }
                    if (swap === null) break;
                    [heap[idx], heap[swap]] = [heap[swap], heap[idx]];
                    idx = swap;
                }
            }

            p.draw = function () {
                p.background(10, 10, 18);

                // Draw tree
                if (heap.length > 0) {
                    drawNode(0, W / 2, 40, W / 4);
                }

                p.fill(100);
                p.textSize(13);
                p.textAlign(p.CENTER);
                p.text(`${message} (Click canvas to Extract Min)`, W / 2, H - 15);
                p.text('Min Heap: Parent <= Children', W / 2, 20);
            };

            function drawNode(i, x, y, gap) {
                if (i >= heap.length) return;

                // Draw edges
                let left = 2 * i + 1;
                let right = 2 * i + 2;

                p.stroke(60, 60, 80);
                p.strokeWeight(2);
                if (left < heap.length) p.line(x, y, x - gap, y + 50);
                if (right < heap.length) p.line(x, y, x + gap, y + 50);

                // Draw node
                p.fill(68, 136, 255);
                p.noStroke();
                p.circle(x, y, 35);
                p.fill(255);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(14);
                p.text(heap[i], x, y);

                // Recurse
                drawNode(left, x - gap, y + 50, gap / 2);
                drawNode(right, x + gap, y + 50, gap / 2);
            }
        };
        // Grid Pathfinding Visualizer (A*)
        let gridPathfindingSketch = function (p) {
            let cols = 41;
            let rows = 21;
            let grid = [];
            let w, h;

            let openSet = [];
            let closedSet = [];
            let start;
            let end;
            let path = [];

            let running = false;
            let finished = false;
            let noSolution = false;

            p.setup = function () {
                p.createCanvas(600, 300);
                w = p.width / cols;
                h = p.height / rows;
                resetGrid();
            };

            function Node(i, j) {
                this.i = i;
                this.j = j;
                this.f = 0;
                this.g = 0;
                this.h = 0;
                this.neighbors = [];
                this.previous = undefined;
                this.wall = false;
                this.visited = false; // For maze gen

                // Randomly add walls initially (10% chance)
                if (p.random(1) < 0.1) this.wall = true;

                this.show = function (col) {
                    p.fill(col);
                    if (this.wall) p.fill(40);
                    p.stroke(0);
                    p.rect(this.i * w, this.j * h, w - 1, h - 1);
                };

                this.addNeighbors = function (grid) {
                    let i = this.i;
                    let j = this.j;
                    if (i < cols - 1) this.neighbors.push(grid[i + 1][j]);
                    if (i > 0) this.neighbors.push(grid[i - 1][j]);
                    if (j < rows - 1) this.neighbors.push(grid[i][j + 1]);
                    if (j > 0) this.neighbors.push(grid[i][j - 1]);
                };
            }

            function resetGrid() {
                grid = new Array(cols);
                for (let i = 0; i < cols; i++) {
                    grid[i] = new Array(rows);
                    for (let j = 0; j < rows; j++) {
                        grid[i][j] = new Node(i, j);
                    }
                }

                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        grid[i][j].addNeighbors(grid);
                    }
                }

                start = grid[0][0];
                end = grid[cols - 1][rows - 1];
                start.wall = false;
                end.wall = false;

                openSet = [start];
                closedSet = [];
                path = [];
                running = false;
                finished = false;
                noSolution = false;
            }

            window.resetViz = resetGrid;

            window.startViz = function () {
                if (finished || noSolution) resetGrid();
                running = true;
            };

            // Recursive Backtracker Maze Generator
            p.keyPressed = function () {
                if (p.key === 'm' || p.key === 'M') {
                    resetGrid();
                    generateMaze();
                }
            };

            function generateMaze() {
                // 1. Start with all walls
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        grid[i][j].wall = true;
                        grid[i][j].visited = false;
                    }
                }

                let stack = [];
                let current = grid[1][1];
                current.wall = false;
                current.visited = true;
                stack.push(current);

                while (stack.length > 0) {
                    current = stack.pop();
                    let neighbors = [];

                    // Look for neighbors 2 steps away
                    let i = current.i;
                    let j = current.j;

                    let dirs = [
                        { x: 0, y: -2 }, { x: 0, y: 2 },
                        { x: -2, y: 0 }, { x: 2, y: 0 }
                    ];

                    for (let d of dirs) {
                        let ni = i + d.x;
                        let nj = j + d.y;
                        if (ni > 0 && ni < cols - 1 && nj > 0 && nj < rows - 1) {
                            if (!grid[ni][nj].visited) {
                                neighbors.push(grid[ni][nj]);
                            }
                        }
                    }

                    if (neighbors.length > 0) {
                        stack.push(current);

                        let next = p.random(neighbors);
                        // Remove wall between
                        let midI = i + (next.i - i) / 2;
                        let midJ = j + (next.j - j) / 2;
                        grid[midI][midJ].wall = false;
                        grid[midI][midJ].visited = true;

                        next.wall = false;
                        next.visited = true;
                        stack.push(next);
                    }
                }

                // Ensure start/end are clear
                start.wall = false;
                end.wall = false;
                grid[1][0].wall = false; // Entrance
                grid[cols - 2][rows - 1].wall = false; // Exit
            }

            function removeFromArray(arr, elt) {
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] === elt) {
                        arr.splice(i, 1);
                    }
                }
            }

            function heuristic(a, b) {
                // Manhattan distance
                return p.abs(a.i - b.i) + p.abs(a.j - b.j);
            }

            p.draw = function () {
                p.background(255);

                if (running && !finished && !noSolution) {
                    // Logic loop (A*)
                    if (openSet.length > 0) {
                        let winner = 0;
                        for (let i = 0; i < openSet.length; i++) {
                            if (openSet[i].f < openSet[winner].f) {
                                winner = i;
                            }
                        }
                        let current = openSet[winner];

                        if (current === end) {
                            finished = true;
                            running = false;
                        }

                        removeFromArray(openSet, current);
                        closedSet.push(current);

                        let neighbors = current.neighbors;
                        for (let i = 0; i < neighbors.length; i++) {
                            let neighbor = neighbors[i];

                            if (!closedSet.includes(neighbor) && !neighbor.wall) {
                                let tempG = current.g + 1;

                                let newPath = false;
                                if (openSet.includes(neighbor)) {
                                    if (tempG < neighbor.g) {
                                        neighbor.g = tempG;
                                        newPath = true;
                                    }
                                } else {
                                    neighbor.g = tempG;
                                    newPath = true;
                                    openSet.push(neighbor);
                                }

                                if (newPath) {
                                    neighbor.h = heuristic(neighbor, end);
                                    neighbor.f = neighbor.g + neighbor.h;
                                    neighbor.previous = current;
                                }
                            }
                        }
                    } else {
                        noSolution = true;
                        running = false;
                    }
                }

                // Interaction: Draw walls
                if (p.mouseIsPressed && !running && !finished) {
                    let x = p.floor(p.mouseX / w);
                    let y = p.floor(p.mouseY / h);
                    if (x >= 0 && x < cols && y >= 0 && y < rows) {
                        if (grid[x][y] !== start && grid[x][y] !== end) {
                            grid[x][y].wall = true;
                        }
                    }
                }

                // Drawing
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        grid[i][j].show(p.color(255));
                    }
                }

                for (let i = 0; i < closedSet.length; i++) {
                    closedSet[i].show(p.color(255, 100, 100, 100)); // Red tint explored
                }

                for (let i = 0; i < openSet.length; i++) {
                    openSet[i].show(p.color(100, 255, 100, 100)); // Green tint candidates
                }

                // Find path
                if (!finished && !noSolution && openSet.length > 0) {
                    path = [];
                    let temp = openSet[0]; // Just showing some path potential ? No, from current winner?
                    // Actually let's trace from closed set's latest? Or just start end logic?
                    // Usually we trace back from end ONLY when finished.
                    // But we can trace back from current 'best' node to show progress?
                    // Let's trace back from the node with lowest f in openSet
                    let winner = 0;
                    for (let i = 0; i < openSet.length; i++) {
                        if (openSet[i].f < openSet[winner].f) winner = i;
                    }
                    let current = openSet[winner];
                    path = [];
                    let tempP = current;
                    path.push(tempP);
                    while (tempP.previous) {
                        path.push(tempP.previous);
                        tempP = tempP.previous;
                    }
                } else if (finished) {
                    path = [];
                    let temp = end;
                    path.push(temp);
                    while (temp.previous) {
                        path.push(temp.previous);
                        temp = temp.previous;
                    }
                }

                for (let i = 0; i < path.length; i++) {
                    path[i].show(p.color(0, 0, 255, 150)); // Blue path
                }

                // Draw Start/End on top
                p.fill(0, 255, 0);
                p.rect(start.i * w, start.j * h, w - 1, h - 1);
                p.fill(255, 0, 0);
                p.rect(end.i * w, end.j * h, w - 1, h - 1);

                p.fill(0);
                p.noStroke();
                p.textSize(14);
                p.textAlign(p.CENTER);
                let status = "Draw Walls (Click & Drag) -> Start";
                if (running) status = "Finding Path...";
                if (finished) status = "Path Found!";
                if (noSolution) status = "No Path Possible!";
                p.fill(100);
                p.text(status, p.width / 2, p.height - 5);
            };
        };

        // Dynamic Programming Visualization (Fibonacci)
        let dpFibSketch = function (p) {
            let n = 5;
            let mode = 'recursion'; // 'recursion' or 'dp'
            let nodes = [];
            let memoTable = [];
            let running = false;
            let finished = false;
            let animationQueue = [];
            let currentStep = 0;

            p.setup = function () {
                p.createCanvas(600, 350);
                resetViz();
            };

            window.resetViz = function () {
                running = false;
                finished = false;
                nodes = [];
                memoTable = new Array(n + 1).fill(null);
                animationQueue = [];
                currentStep = 0;

                if (mode === 'recursion') {
                    // Pre-calculate tree positions
                    buildTree(n, p.width / 2, 40, p.width / 2);
                } else {
                    // Setup DP table visualization
                }
            };

            window.startViz = function () {
                if (finished) resetViz();
                running = true;
                if (animationQueue.length === 0) {
                    if (mode === 'recursion') {
                        generateRecursionSteps(n, nodes[0].id);
                    } else {
                        generateDPSteps();
                    }
                }
            };

            // Toggle Mode (interactive)
            p.keyPressed = function () {
                if (p.key === 'm' || p.key === 'M') {
                    mode = mode === 'recursion' ? 'dp' : 'recursion';
                    resetViz();
                }
                if (p.key >= '3' && p.key <= '6') {
                    n = parseInt(p.key);
                    resetViz();
                }
            };

            // Tree Builder
            let nodeIdCounter = 0;
            function buildTree(val, x, y, w) {
                nodeIdCounter = 0;
                nodes = [];

                function helper(v, x, y, w, depth) {
                    let id = nodeIdCounter++;
                    let node = { id, val: v, x, y, state: 'pending', children: [], parent: null, result: null };
                    nodes.push(node);

                    if (v <= 1) {
                        node.result = v;
                        return node;
                    }

                    // Left child
                    let left = helper(v - 1, x - w / 2, y + 50, w / 2, depth + 1);
                    left.parent = node;
                    node.children.push(left);

                    // Right child
                    let right = helper(v - 2, x + w / 2, y + 50, w / 2, depth + 1);
                    right.parent = node;
                    node.children.push(right);

                    return node;
                }

                helper(val, x, y, w / 1.5, 0);
            }

            // Step Generators
            function generateRecursionSteps(val, nodeId) {
                let node = nodes[nodeId];

                // 1. Visit
                animationQueue.push({ type: 'visit', id: nodeId });

                if (val <= 1) {
                    // Base case
                    animationQueue.push({ type: 'result', id: nodeId, val: val });
                    return val;
                }

                // Recurse Left
                let leftVal = generateRecursionSteps(val - 1, node.children[0].id);

                // Recurse Right
                let rightVal = generateRecursionSteps(val - 2, node.children[1].id);

                // Combine
                let res = leftVal + rightVal;
                animationQueue.push({ type: 'result', id: nodeId, val: res });
                return res;
            }

            function generateDPSteps() {
                // Simpler DP Logic:
                let dp = new Array(n + 1).fill(0);
                for (let i = 0; i <= n; i++) {
                    animationQueue.push({ type: 'dp-visit', idx: i });
                    if (i <= 1) dp[i] = i;
                    else dp[i] = dp[i - 1] + dp[i - 2];

                    animationQueue.push({ type: 'dp-set', idx: i, val: dp[i] });
                }
            }

            p.draw = function () {
                p.background(255);

                // Animation Player
                if (running && !finished) {
                    if (p.frameCount % 20 === 0) { // Speed control
                        if (currentStep < animationQueue.length) {
                            let step = animationQueue[currentStep];
                            applyStep(step);
                            currentStep++;
                        } else {
                            finished = true;
                            running = false;
                        }
                    }
                }

                // Draw Text
                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT, p.TOP);
                p.textSize(16);
                p.text(`Mode: ${mode.toUpperCase()} (Press 'M')`, 10, 10);
                p.text(`N: ${n} (Press 3-6)`, 10, 30);

                if (mode === 'recursion') {
                    drawTree();
                } else {
                    drawDP();
                }
            };

            function applyStep(step) {
                if (step.type === 'visit') {
                    nodes[step.id].state = 'active';
                } else if (step.type === 'result') {
                    nodes[step.id].state = 'done';
                    nodes[step.id].result = step.val;
                } else if (step.type === 'dp-visit') {
                    // Highlight cell logic could be added here
                } else if (step.type === 'dp-set') {
                    memoTable[step.idx] = step.val;
                }
            }

            function drawTree() {
                p.textAlign(p.CENTER, p.CENTER);
                for (let node of nodes) {
                    if (node.parent) {
                        p.stroke(0);
                        p.line(node.x, node.y, node.parent.x, node.parent.y);
                    }
                }

                for (let node of nodes) {
                    let col = p.color(255);
                    if (node.state === 'active') col = p.color(255, 255, 0);
                    if (node.state === 'done') col = p.color(100, 255, 100);

                    p.fill(col);
                    p.stroke(0);
                    p.circle(node.x, node.y, 30);

                    p.fill(0);
                    p.noStroke();
                    p.textSize(12);
                    if (node.result !== null) {
                        p.text(node.result, node.x, node.y);
                    } else {
                        p.text(`f(${node.val})`, node.x, node.y);
                    }
                }
            }

            function drawDP() {
                let cellW = 50;
                let startX = 50;
                let y = 150;

                for (let i = 0; i <= n; i++) {
                    p.stroke(0);
                    p.fill(memoTable[i] !== null ? p.color(100, 255, 100) : p.color(240));
                    p.rect(startX + i * cellW, y, cellW, cellW);

                    p.fill(0);
                    p.noStroke();
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text(i, startX + i * cellW + cellW / 2, y - 20); // Index
                    if (memoTable[i] !== null) {
                        p.text(memoTable[i], startX + i * cellW + cellW / 2, y + cellW / 2);
                    }
                }

                p.textAlign(p.LEFT);
                p.fill(0);
                p.text("Memoization Table (Array)", 50, 100);
            }
        };

        // 0/1 Knapsack Visualization
        let dpKnapsackSketch = function (p) {
            let weights = [2, 3, 4];
            let values = [3, 4, 5];
            let W = 5;
            let dp = [];
            let running = false;
            let finished = false;
            let currentI = 0, currentW = 0;

            p.setup = function () {
                p.createCanvas(600, 350);
                resetViz();
            };

            window.resetViz = function () {
                running = false;
                finished = false;
                currentI = 1;
                currentW = 0;
                const n = weights.length;
                dp = Array(n + 1).fill(null).map(() => Array(W + 1).fill(0));
            };

            window.startViz = function () {
                if (finished) resetViz();
                running = true;
            };

            p.draw = function () {
                p.background(255);

                if (running && !finished) {
                    if (p.frameCount % 15 === 0) {
                        // DP step
                        let i = currentI, w = currentW;
                        dp[i][w] = dp[i - 1][w];
                        if (weights[i - 1] <= w) {
                            const take = values[i - 1] + dp[i - 1][w - weights[i - 1]];
                            dp[i][w] = Math.max(dp[i][w], take);
                        }

                        currentW++;
                        if (currentW > W) {
                            currentW = 0;
                            currentI++;
                            if (currentI > weights.length) {
                                finished = true;
                                running = false;
                            }
                        }
                    }
                }

                drawTable();
            };

            function drawTable() {
                let cellW = 40, cellH = 35;
                let startX = 80, startY = 80;

                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT, p.TOP);
                p.textSize(14);
                p.text("0/1 Knapsack: weights=[2,3,4], values=[3,4,5], W=5", 10, 10);
                p.text("Items (rows) vs Capacity (cols)", 10, 30);

                // Header row (capacities)
                p.textAlign(p.CENTER, p.CENTER);
                for (let w = 0; w <= W; w++) {
                    p.text(w, startX + w * cellW + cellW / 2, startY - 15);
                }

                // Draw table
                for (let i = 0; i <= weights.length; i++) {
                    // Row label
                    p.textAlign(p.RIGHT, p.CENTER);
                    p.text(i === 0 ? "0" : `Item ${i}`, startX - 10, startY + i * cellH + cellH / 2);

                    for (let w = 0; w <= W; w++) {
                        let col = p.color(240);
                        if (i === currentI && w === currentW && running) {
                            col = p.color(255, 255, 0); // Current cell
                        } else if (i < currentI || (i === currentI && w < currentW)) {
                            col = p.color(100, 255, 100); // Filled
                        }

                        p.fill(col);
                        p.stroke(0);
                        p.rect(startX + w * cellW, startY + i * cellH, cellW, cellH);

                        p.fill(0);
                        p.noStroke();
                        p.textAlign(p.CENTER, p.CENTER);
                        if (dp[i] && dp[i][w] !== undefined) {
                            p.text(dp[i][w], startX + w * cellW + cellW / 2, startY + i * cellH + cellH / 2);
                        }
                    }
                }

                if (finished) {
                    p.fill(0, 150, 0);
                    p.textAlign(p.LEFT);
                    p.text(`Max Value: ${dp[weights.length][W]}`, 10, 300);
                }
            }
        };

        // LCS Visualization
        let dpLcsSketch = function (p) {
            let s1 = "ABCDGH";
            let s2 = "AEDFHR";
            let dp = [];
            let running = false;
            let finished = false;
            let currentI = 1, currentJ = 1;

            p.setup = function () {
                p.createCanvas(600, 350);
                resetViz();
            };

            window.resetViz = function () {
                running = false;
                finished = false;
                currentI = 1;
                currentJ = 1;
                const m = s1.length, n = s2.length;
                dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            };

            window.startViz = function () {
                if (finished) resetViz();
                running = true;
            };

            p.draw = function () {
                p.background(255);

                if (running && !finished) {
                    if (p.frameCount % 12 === 0) {
                        let i = currentI, j = currentJ;
                        if (s1[i - 1] === s2[j - 1]) {
                            dp[i][j] = 1 + dp[i - 1][j - 1];
                        } else {
                            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                        }

                        currentJ++;
                        if (currentJ > s2.length) {
                            currentJ = 1;
                            currentI++;
                            if (currentI > s1.length) {
                                finished = true;
                                running = false;
                            }
                        }
                    }
                }

                drawTable();
            };

            function drawTable() {
                let cellW = 35, cellH = 30;
                let startX = 60, startY = 80;

                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT, p.TOP);
                p.textSize(14);
                p.text(`LCS of "${s1}" and "${s2}"`, 10, 10);

                // Header row (s2 chars)
                p.textAlign(p.CENTER, p.CENTER);
                p.text("-", startX + cellW / 2, startY - 15);
                for (let j = 0; j < s2.length; j++) {
                    p.text(s2[j], startX + (j + 1) * cellW + cellW / 2, startY - 15);
                }

                // Draw table
                for (let i = 0; i <= s1.length; i++) {
                    // Row label
                    p.textAlign(p.RIGHT, p.CENTER);
                    p.text(i === 0 ? "-" : s1[i - 1], startX - 10, startY + i * cellH + cellH / 2);

                    for (let j = 0; j <= s2.length; j++) {
                        let col = p.color(240);
                        if (i === currentI && j === currentJ && running) {
                            col = p.color(255, 255, 0);
                        } else if (i > 0 && j > 0 && (i < currentI || (i === currentI && j < currentJ))) {
                            // Highlight match cells
                            if (s1[i - 1] === s2[j - 1]) {
                                col = p.color(100, 200, 255);
                            } else {
                                col = p.color(200, 255, 200);
                            }
                        }

                        p.fill(col);
                        p.stroke(0);
                        p.rect(startX + j * cellW, startY + i * cellH, cellW, cellH);

                        p.fill(0);
                        p.noStroke();
                        p.textAlign(p.CENTER, p.CENTER);
                        if (dp[i] && dp[i][j] !== undefined) {
                            p.text(dp[i][j], startX + j * cellW + cellW / 2, startY + i * cellH + cellH / 2);
                        }
                    }
                }

                if (finished) {
                    p.fill(0, 150, 0);
                    p.textAlign(p.LEFT);
                    p.text(`LCS Length: ${dp[s1.length][s2.length]}`, 10, 310);
                }
            }
        };

        // Coin Change Visualization
        let dpCoinSketch = function (p) {
            let coins = [1, 2, 5];
            let amount = 11;
            let dp = [];
            let running = false;
            let finished = false;
            let currentA = 1;

            p.setup = function () {
                p.createCanvas(600, 300);
                resetViz();
            };

            window.resetViz = function () {
                running = false;
                finished = false;
                currentA = 1;
                dp = new Array(amount + 1).fill(Infinity);
                dp[0] = 0;
            };

            window.startViz = function () {
                if (finished) resetViz();
                running = true;
            };

            p.draw = function () {
                p.background(255);

                if (running && !finished) {
                    if (p.frameCount % 10 === 0) {
                        for (const coin of coins) {
                            if (coin <= currentA) {
                                dp[currentA] = Math.min(dp[currentA], 1 + dp[currentA - coin]);
                            }
                        }
                        currentA++;
                        if (currentA > amount) {
                            finished = true;
                            running = false;
                        }
                    }
                }

                drawTable();
            };

            function drawTable() {
                let cellW = 45, cellH = 40;
                let startX = 30, startY = 100;

                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT, p.TOP);
                p.textSize(14);
                p.text(`Coin Change: coins=[${coins.join(',')}], amount=${amount}`, 10, 10);
                p.text("dp[i] = min coins to make amount i", 10, 30);

                // Draw cells
                for (let a = 0; a <= amount; a++) {
                    let col = p.color(240);
                    if (a === currentA && running) {
                        col = p.color(255, 255, 0);
                    } else if (a < currentA) {
                        col = dp[a] === Infinity ? p.color(255, 150, 150) : p.color(100, 255, 100);
                    }

                    p.fill(col);
                    p.stroke(0);
                    p.rect(startX + a * cellW, startY, cellW, cellH);

                    // Index
                    p.fill(0);
                    p.noStroke();
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(12);
                    p.text(a, startX + a * cellW + cellW / 2, startY - 15);

                    // Value
                    if (dp[a] !== undefined) {
                        p.text(dp[a] === Infinity ? "‚àû" : dp[a], startX + a * cellW + cellW / 2, startY + cellH / 2);
                    }
                }

                if (finished) {
                    p.fill(0, 150, 0);
                    p.textAlign(p.LEFT);
                    p.textSize(16);
                    let result = dp[amount] === Infinity ? "No solution" : dp[amount] + " coins";
                    p.text(`Result: ${result}`, 10, 180);
                }
            }
        };

        // N-Queens Visualization  
        let nQueensSketch = function (p) {
            let n = 4;
            let board = [];
            let solutions = [];
            let currentSolution = 0;
            let running = false;
            let solveStack = [];
            let solved = false;

            p.setup = function () {
                p.createCanvas(600, 350);
                resetViz();
            };

            window.resetViz = function () {
                running = false;
                solved = false;
                solutions = [];
                currentSolution = 0;
                board = Array(n).fill(-1); // board[row] = col of queen
                solveStack = [{ row: 0, col: 0 }];
            };

            window.startViz = function () {
                if (solved) {
                    // Cycle through solutions
                    if (solutions.length > 0) {
                        currentSolution = (currentSolution + 1) % solutions.length;
                        board = [...solutions[currentSolution]];
                    }
                    return;
                }
                running = true;
            };

            // Key to change N
            p.keyPressed = function () {
                if (p.key >= '4' && p.key <= '8') {
                    n = parseInt(p.key);
                    resetViz();
                }
            };

            function isSafe(row, col) {
                for (let r = 0; r < row; r++) {
                    let c = board[r];
                    if (c === col) return false;
                    if (Math.abs(c - col) === Math.abs(r - row)) return false;
                }
                return true;
            }

            p.draw = function () {
                p.background(255);

                if (running && !solved) {
                    if (p.frameCount % 5 === 0) {
                        // One step of backtracking
                        if (solveStack.length > 0) {
                            let state = solveStack.pop();
                            let row = state.row;
                            let col = state.col;

                            // Clear rows >= current
                            for (let r = row; r < n; r++) board[r] = -1;

                            // Find next valid position
                            let found = false;
                            for (let c = col; c < n; c++) {
                                if (isSafe(row, c)) {
                                    board[row] = c;
                                    if (row === n - 1) {
                                        // Found solution
                                        solutions.push([...board]);
                                    } else {
                                        solveStack.push({ row: row, col: c + 1 });
                                        solveStack.push({ row: row + 1, col: 0 });
                                    }
                                    found = true;
                                    break;
                                }
                            }
                        } else {
                            solved = true;
                            running = false;
                            if (solutions.length > 0) {
                                board = [...solutions[0]];
                            }
                        }
                    }
                }

                drawBoard();
            };

            function drawBoard() {
                let cellSize = Math.min(250 / n, 50);
                let startX = 50, startY = 60;

                p.fill(0);
                p.noStroke();
                p.textSize(14);
                p.textAlign(p.LEFT, p.TOP);
                p.text(`N-Queens (N=${n}) - Press 4-8 to change`, 10, 10);
                if (solved) {
                    p.text(`Found ${solutions.length} solutions. Click Start to cycle.`, 10, 30);
                }

                // Draw board
                for (let r = 0; r < n; r++) {
                    for (let c = 0; c < n; c++) {
                        let col = (r + c) % 2 === 0 ? p.color(240) : p.color(180);
                        p.fill(col);
                        p.stroke(0);
                        p.rect(startX + c * cellSize, startY + r * cellSize, cellSize, cellSize);
                    }
                }

                // Draw queens
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(cellSize * 0.7);
                for (let r = 0; r < n; r++) {
                    if (board[r] !== -1) {
                        let c = board[r];
                        p.fill(0);
                        p.noStroke();
                        p.text("‚ôõ", startX + c * cellSize + cellSize / 2, startY + r * cellSize + cellSize / 2);
                    }
                }

                // Show current solution number
                if (solved && solutions.length > 0) {
                    p.textSize(14);
                    p.textAlign(p.LEFT);
                    p.text(`Solution ${currentSolution + 1} of ${solutions.length}`, 10, 320);
                }
            }
        };

        // Sudoku Solver Visualization
        let sudokuSketch = function (p) {
            // Sample puzzle (0 = empty)
            const initialBoard = [
                [5, 3, 0, 0, 7, 0, 0, 0, 0],
                [6, 0, 0, 1, 9, 5, 0, 0, 0],
                [0, 9, 8, 0, 0, 0, 0, 6, 0],
                [8, 0, 0, 0, 6, 0, 0, 0, 3],
                [4, 0, 0, 8, 0, 3, 0, 0, 1],
                [7, 0, 0, 0, 2, 0, 0, 0, 6],
                [0, 6, 0, 0, 0, 0, 2, 8, 0],
                [0, 0, 0, 4, 1, 9, 0, 0, 5],
                [0, 0, 0, 0, 8, 0, 0, 7, 9]
            ];
            let board = [];
            let originalBoard = [];
            let running = false;
            let solved = false;
            let animationStack = [];
            let currentStep = 0;
            let currentCell = null;
            let backtracks = 0;

            p.setup = function () {
                p.createCanvas(600, 380);
                resetViz();
            };

            window.resetViz = function () {
                running = false;
                solved = false;
                currentStep = 0;
                backtracks = 0;
                currentCell = null;
                animationStack = [];
                board = initialBoard.map(row => [...row]);
                originalBoard = initialBoard.map(row => [...row]);
                generateSolveSteps();
            };

            window.startViz = function () {
                if (solved) resetViz();
                running = true;
            };

            function isValid(b, row, col, num) {
                for (let x = 0; x < 9; x++) {
                    if (b[row][x] === num || b[x][col] === num) return false;
                }
                let boxRow = Math.floor(row / 3) * 3;
                let boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (b[boxRow + i][boxCol + j] === num) return false;
                    }
                }
                return true;
            }

            function generateSolveSteps() {
                let b = initialBoard.map(row => [...row]);
                animationStack = [];

                function solve() {
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            if (b[row][col] === 0) {
                                for (let num = 1; num <= 9; num++) {
                                    animationStack.push({ type: 'try', row, col, num });
                                    if (isValid(b, row, col, num)) {
                                        b[row][col] = num;
                                        animationStack.push({ type: 'place', row, col, num });
                                        if (solve()) return true;
                                        b[row][col] = 0;
                                        animationStack.push({ type: 'backtrack', row, col });
                                    }
                                }
                                return false;
                            }
                        }
                    }
                    return true;
                }
                solve();
                animationStack.push({ type: 'solved' });
            }

            p.draw = function () {
                p.background(255);

                if (running && !solved) {
                    if (p.frameCount % 3 === 0 && currentStep < animationStack.length) {
                        let step = animationStack[currentStep];
                        if (step.type === 'try') {
                            currentCell = { row: step.row, col: step.col };
                        } else if (step.type === 'place') {
                            board[step.row][step.col] = step.num;
                            currentCell = { row: step.row, col: step.col };
                        } else if (step.type === 'backtrack') {
                            board[step.row][step.col] = 0;
                            backtracks++;
                            currentCell = { row: step.row, col: step.col };
                        } else if (step.type === 'solved') {
                            solved = true;
                            running = false;
                        }
                        currentStep++;
                    }
                }

                drawBoard();
            };

            function drawBoard() {
                let cellSize = 35;
                let startX = 30, startY = 50;

                p.fill(0);
                p.noStroke();
                p.textSize(14);
                p.textAlign(p.LEFT, p.TOP);
                p.text('Sudoku Solver - Backtracking Visualization', 10, 10);
                p.textSize(12);
                p.text(`Backtracks: ${backtracks}`, 400, 10);

                // Draw cells
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        let x = startX + c * cellSize;
                        let y = startY + r * cellSize;

                        // Color logic
                        let col = p.color(255);
                        if (originalBoard[r][c] !== 0) {
                            col = p.color(220, 220, 240); // Given cells
                        } else if (currentCell && currentCell.row === r && currentCell.col === c) {
                            col = p.color(255, 255, 100); // Current cell
                        } else if (board[r][c] !== 0) {
                            col = p.color(180, 255, 180); // Filled by algorithm
                        }

                        p.fill(col);
                        p.stroke(100);
                        p.strokeWeight(1);
                        p.rect(x, y, cellSize, cellSize);

                        // Draw value
                        if (board[r][c] !== 0) {
                            p.fill(originalBoard[r][c] !== 0 ? p.color(0, 0, 150) : p.color(0, 100, 0));
                            p.noStroke();
                            p.textAlign(p.CENTER, p.CENTER);
                            p.textSize(18);
                            p.text(board[r][c], x + cellSize / 2, y + cellSize / 2);
                        }
                    }
                }

                // Draw thick lines for 3x3 boxes
                p.stroke(0);
                p.strokeWeight(3);
                for (let i = 0; i <= 3; i++) {
                    p.line(startX + i * 3 * cellSize, startY, startX + i * 3 * cellSize, startY + 9 * cellSize);
                    p.line(startX, startY + i * 3 * cellSize, startX + 9 * cellSize, startY + i * 3 * cellSize);
                }

                if (solved) {
                    p.fill(0, 150, 0);
                    p.noStroke();
                    p.textSize(16);
                    p.textAlign(p.LEFT);
                    p.text('‚úì Puzzle Solved!', 400, 30);
                }

                // Legend
                p.textSize(11);
                p.textAlign(p.LEFT, p.TOP);
                p.fill(220, 220, 240);
                p.rect(380, 60, 15, 15);
                p.fill(0);
                p.text('Given', 400, 62);

                p.fill(180, 255, 180);
                p.rect(380, 85, 15, 15);
                p.fill(0);
                p.text('Solved', 400, 87);

                p.fill(255, 255, 100);
                p.rect(380, 110, 15, 15);
                p.fill(0);
                p.text('Current', 400, 112);
            }
        };

        // Maze Solver Visualization
        let mazeSketch = function (p) {
            let n = 10;
            let maze = [];
            let solution = [];
            let running = false;
            let solved = false;
            let noPath = false;
            let animationStack = [];
            let currentStep = 0;
            let currentCell = null;
            let backtracks = 0;

            p.setup = function () {
                p.createCanvas(600, 380);
                resetViz();
            };

            window.resetViz = function () {
                running = false;
                solved = false;
                noPath = false;
                currentStep = 0;
                backtracks = 0;
                currentCell = null;
                animationStack = [];
                generateMaze();
                solution = Array(n).fill(null).map(() => Array(n).fill(0));
            };

            window.startViz = function () {
                if (solved || noPath) resetViz();
                generateSolveSteps();
                running = true;
            };

            function generateMaze() {
                // Generate a random maze with guaranteed path using DFS
                maze = Array(n).fill(null).map(() => Array(n).fill(0));
                let visited = Array(n).fill(null).map(() => Array(n).fill(false));

                function carve(x, y) {
                    visited[x][y] = true;
                    maze[x][y] = 1;

                    let dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                    dirs = dirs.sort(() => Math.random() - 0.5);

                    for (let [dx, dy] of dirs) {
                        let nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny]) {
                            carve(nx, ny);
                        }
                    }
                }

                carve(0, 0);
                maze[n - 1][n - 1] = 1; // Ensure end is open

                // Add some extra paths for variety
                for (let i = 0; i < n * 2; i++) {
                    let rx = Math.floor(Math.random() * n);
                    let ry = Math.floor(Math.random() * n);
                    maze[rx][ry] = 1;
                }
            }

            function generateSolveSteps() {
                let sol = Array(n).fill(null).map(() => Array(n).fill(0));
                animationStack = [];

                function isSafe(x, y) {
                    return x >= 0 && x < n && y >= 0 && y < n && maze[x][y] === 1 && sol[x][y] === 0;
                }

                function solve(x, y) {
                    if (x === n - 1 && y === n - 1) {
                        sol[x][y] = 1;
                        animationStack.push({ type: 'visit', x, y });
                        animationStack.push({ type: 'solved' });
                        return true;
                    }

                    if (isSafe(x, y)) {
                        sol[x][y] = 1;
                        animationStack.push({ type: 'visit', x, y });

                        // Try Down, Right, Up, Left
                        const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
                        for (let [dx, dy] of dirs) {
                            if (solve(x + dx, y + dy)) return true;
                        }

                        sol[x][y] = 0;
                        animationStack.push({ type: 'backtrack', x, y });
                        return false;
                    }
                    return false;
                }

                if (!solve(0, 0)) {
                    animationStack.push({ type: 'nopath' });
                }
            }

            p.draw = function () {
                p.background(255);

                if (running && !solved && !noPath) {
                    if (p.frameCount % 5 === 0 && currentStep < animationStack.length) {
                        let step = animationStack[currentStep];
                        if (step.type === 'visit') {
                            solution[step.x][step.y] = 1;
                            currentCell = { x: step.x, y: step.y };
                        } else if (step.type === 'backtrack') {
                            solution[step.x][step.y] = 0;
                            backtracks++;
                            currentCell = { x: step.x, y: step.y };
                        } else if (step.type === 'solved') {
                            solved = true;
                            running = false;
                        } else if (step.type === 'nopath') {
                            noPath = true;
                            running = false;
                        }
                        currentStep++;
                    }
                }

                drawMaze();
            };

            function drawMaze() {
                let cellSize = 30;
                let startX = 30, startY = 50;

                p.fill(0);
                p.noStroke();
                p.textSize(14);
                p.textAlign(p.LEFT, p.TOP);
                p.text('Maze Solver - Backtracking (Rat in a Maze)', 10, 10);
                p.textSize(12);
                p.text(`Backtracks: ${backtracks}`, 400, 10);

                // Draw cells
                for (let r = 0; r < n; r++) {
                    for (let c = 0; c < n; c++) {
                        let x = startX + c * cellSize;
                        let y = startY + r * cellSize;

                        // Color logic
                        let col;
                        if (maze[r][c] === 0) {
                            col = p.color(40, 40, 40); // Wall
                        } else if (r === 0 && c === 0) {
                            col = p.color(100, 200, 100); // Start
                        } else if (r === n - 1 && c === n - 1) {
                            col = p.color(255, 100, 100); // End
                        } else if (currentCell && currentCell.x === r && currentCell.y === c) {
                            col = p.color(255, 255, 100); // Current
                        } else if (solution[r][c] === 1) {
                            col = p.color(100, 150, 255); // Path
                        } else {
                            col = p.color(240); // Open
                        }

                        p.fill(col);
                        p.stroke(80);
                        p.strokeWeight(1);
                        p.rect(x, y, cellSize, cellSize);
                    }
                }

                // Draw start and end markers
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(16);
                p.fill(0);
                p.noStroke();
                p.text('S', startX + cellSize / 2, startY + cellSize / 2);
                p.text('E', startX + (n - 1) * cellSize + cellSize / 2, startY + (n - 1) * cellSize + cellSize / 2);

                if (solved) {
                    p.fill(0, 150, 0);
                    p.textSize(16);
                    p.textAlign(p.LEFT);
                    p.text('‚úì Path Found!', 400, 30);
                }
                if (noPath) {
                    p.fill(200, 0, 0);
                    p.textSize(16);
                    p.textAlign(p.LEFT);
                    p.text('‚úó No Path Exists!', 400, 30);
                }

                // Legend
                p.textSize(11);
                p.textAlign(p.LEFT, p.TOP);

                p.fill(40, 40, 40);
                p.rect(380, 60, 15, 15);
                p.fill(0);
                p.text('Wall', 400, 62);

                p.fill(240);
                p.stroke(80);
                p.rect(380, 85, 15, 15);
                p.fill(0);
                p.noStroke();
                p.text('Open', 400, 87);

                p.fill(100, 150, 255);
                p.rect(380, 110, 15, 15);
                p.fill(0);
                p.text('Path', 400, 112);

                p.fill(255, 255, 100);
                p.rect(380, 135, 15, 15);
                p.fill(0);
                p.text('Current', 400, 137);
            }
        };

        // Sidebar navigation
        document.querySelectorAll('.category-header').forEach(header => {
            header.addEventListener('click', () => {
                const category = header.parentElement;
                category.classList.toggle('expanded');
            });
        });

        document.querySelectorAll('.topic-item').forEach(item => {
            item.addEventListener('click', () => {
                document.querySelectorAll('.topic-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                renderTopic(item.dataset.topic);
            });
        });

        // Load default topic
        renderTopic('bubble-sort');
    </script>
</body>

</html>